# -*- mode: Perl -*-
# /=====================================================================\ #
# |  authblk.sty.ltxml                                                  | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | Bruce Miller <bruce.miller@nist.gov>                        #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #
package LaTeXML::Package::Pool;
use strict;
use warnings;
use LaTeXML::Package;

# NOTE: preliminary implementation focusing on the logic;
# We currently don't layout the author/afflition block quite the way authblk does:
#  * don't combine authors with same affiliation,
#  * don't use marks to associate the author/affiliation

DefMacro('\Affilfont', '\normalfont');
DefMacro('\Authfont',  '\normalfont');
DefMacro('\Authsep',   ',');
DefMacro('\Authand',   ' and ');
DefMacro('\Authands',  ', and ');
DefMacro('\authorcr',  '\\\\\Authfont');

# package bookkeeping
DefConditional('\ifnewaffil');
DefRegister('\affilsep'  => Dimension('1em'));
DefRegister('\@affilsep' => Dimension('1em'));
NewCounter('Maxaffil');
SetCounter('Maxaffil', Number(2));
NewCounter('authors');
NewCounter('affil');
NewCounter('@affil');

DefMacro('\the@affil', 'affil\arabic{@affil}');
DefMacro('\author[]{}', sub {
    return map { Invocation(T_CS('\lx@ab@author'), $_[1], Tokens(@$_)) }
      SplitTokens($_[2], T_CS('\and'), T_OTHER(',')); });

DefMacro('\lx@ab@author[]{}',
  '\@add@frontmatter{ltx:creator}[role=author]'
    . '{\@personname{#2}\lx@authormark{\if.#1.\the@affil\else#1\fi}}');

DefConstructor('\lx@authormark{}',
  "^?#mark(<ltx:contact role='affiliationmark' _mark='#mark'></ltx:contact>)()",
  properties => sub { (mark => ToString($_[1])); });

DefConstructor('\affil[]{}',
  "^?#2(<ltx:note mark='#mark' role='affiliationtext'>#2</ltx:note>)()",
  afterDigest => sub {
    my ($stomach, $whatsit) = @_;
    my $mark = $whatsit->getArg(1);
    if (!defined $mark) {
      $mark = Digest(T_CS('\the@affil'));    # get mark
      StepCounter('@affil'); }               # and THEN step counter!
    $whatsit->setProperty(mark => ToString($mark));
    return; });

Tag('ltx:document', afterClose => \&authblkRelocateAffil);

sub authblkRelocateAffil {
  my ($document)   = @_;
  my @author_nodes = $document->findnodes(".//ltx:contact[\@role='affiliationmark' and \@_mark]");
  my @affil_nodes  = $document->findnodes(".//ltx:note[\@role='affiliationtext']");
  # first, unbind all affiliation text nodes - they get reparented or discarded.
  my %mark_to_affil = ();
  for my $affil_node (@affil_nodes) {
    $affil_node->parentNode->removeChild($affil_node);
    # if we get conflicting marks -- which we shouldn't
    # the last node wins
    if (my $mark = $affil_node->getAttribute('mark')) {
      $mark_to_affil{$mark} = $affil_node; } }
  # The most accurate approach here is to go author-by-author,
  # and attach the affiliations in the *exact order* they were requested
  # \author[1,7]{A} and \author[7,1]{B} are intended to be presented in that order.
  for my $author_node (@author_nodes) {
    my @author_marks = split(/\s*,\s*/, ($author_node->getAttribute('_mark') || ''));
    next unless @author_marks;
    $author_node->setAttribute(role => 'affiliation');
    my $author_parent = $author_node->parentNode;
    for my $mark (reverse(@author_marks)) {
      if (my $affil_node = $mark_to_affil{$mark}) {
        my $new_contact = $author_node->cloneNode(0);
        $author_parent->insertAfter($new_contact, $author_node);
        $document->appendClone($new_contact, $affil_node->childNodes); } }
    # at the end, unbind each author-mark template node
    $author_parent->removeChild($author_node); }
  return; }

# we shouldn't need these, but if someone is using them low-level
# might as well provide them
DefMacro('\AB@authnote{}',  '\textsuperscript{\normalfont#1}');
DefMacro('\AB@affilnote{}', '\textsuperscript{\normalfont#1}');

#======================================================================
1;
