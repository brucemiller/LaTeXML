# -*- mode: Perl -*-
# /=====================================================================\ #
# | TeX_Math                                                            | #
# | Core TeX Implementation for LaTeXML                                 | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | Bruce Miller <bruce.miller@nist.gov>                        #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #
package LaTeXML::Package::Pool;
use strict;
use warnings;
use LaTeXML::Package;
#use Unicode::Normalize;
#use LaTeXML::Util::Pathname;
#use List::Util qw(min max);

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Math Family of primitive control sequences
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#======================================================================
# NOT YET IMPLEMENTED !?!?!
#----------------------------------------------------------------------
# \radical                c  makes a radical atom from the delimiter (27-bit number) and the math field.
# \muskipdef              c  creates a symbolic name for a \muskip register.
# \muskip                 iq assigns <muglue> to a \muskip register.
# \nonscript              c  ignores immediately following glue or kern in script and scriptscript styles.

# This should discard following skip/glue;
# Should this digest whatever is following tountil non-glue/kern????
DefPrimitive('\nonscript', undef);
#======================================================================
# The next two sections are the basic LaTeXML Infrastructure for math.
# There are several internal control sequences which need to be renamed!
#======================================================================

# Decide whether we're going into or out of math, inline or display.
Tag('ltx:XMText', autoOpen => 1, autoClose => 1);
DefPrimitiveI('\lx@dollar@default', undef, sub {
    my ($stomach) = @_;
    my $gullet    = $stomach->getGullet;
    my $mode      = LookupValue('MODE');
    my $bound     = LookupValue('BOUND_MODE');
    my $op        = '\lx@begin@inline@math';
    if ($mode eq 'display_math') {
      if ($gullet->ifNext(T_MATH)) {
        $gullet->readToken;
        $op = '\lx@end@display@math'; }
      else {
        # Avoid a Fatal, but we're likely in trouble.
        # Should we switch to text mode? (LaTeX normally wouldn't)
        # Did we miss something and would should have already been in text mode? Possibly...
        # OR, were we in a lenient package that allowed inline math mixed in with display?
        Error('expected', '$', $stomach,
          "Missing \$ closing display math.",
          "Ignoring; expect to be in wrong math/text mode.");
        $op = undef; } }
    elsif ($mode eq 'inline_math') {
      $op = '\\lx@end@inline@math'; }
    # Only check for 2nd $ when within a vertical mode
    elsif (($bound =~ /vertical$/) && ($gullet->ifNext(T_MATH))) {
      $gullet->readToken;
      $op = '\lx@begin@display@math'; }
    $stomach->invokeToken(T_CS($op)) if $op; });
# Let this be the default, conventional $
Let(T_MATH, T_CS('\lx@dollar@default'));
# Obsolete
Let(T_CS('\lx@dollar@in@normalmode'), T_CS('\lx@dollar@default'));
Let(T_CS('\lx@dollar@in@textmode'),   T_CS('\lx@dollar@default'));

#======================================================================
# Math mode in special cases: math alignments, or perverse equations for ...$text$...
# Note that $ within a math alignment (eg array environment),
# switches to text mode! There's no $$ for display math.

# This one is for $ appearing within an alignment that's already math.
# This should switch to text mode (because it's balancing the hidden $
# wrapping each alignment cell!!!!!!)
# However, it should be like a normal $ if it's inside something like \mbox
# that itself makes a text box!!!!!!
# Thus, we need to know at what boxing level we started the last math or text.
# This is all complicated by the need to know _how_ we got into or out of math mode!
# Gawd, this is awful!
# NOTE: Probably the most "Right" thing to do would be to process
# alignments in text mode only (like TeX), sneaking $'s in where needed,
# but then afterwards, morph them into math arrays?
# This would be complicated by the need to hide these $ from untex.
DefPrimitiveI('\lx@dollar@in@mathmode', undef, sub {
    my ($stomach) = @_;
    my $level = $stomach->getBoxingLevel;
    if ((LookupValue('MATH_ALIGN_$_BEGUN') || 0) == $level) { # If we're begun making _something_ with $.
      my @l = ();
      if (LookupValue('IN_MATH')) {                           # But we're somehow in math?
        @l = $stomach->invokeToken(T_CS('\\lx@end@inline@math')); }
      else {
        @l = $stomach->invokeToken(T_CS('\lx@end@inmath@text')); }
      AssignValue('MATH_ALIGN_$_BEGUN' => 0);                 # Reset this AFTER finishing the something
      @l; }
    else {
      AssignValue('MATH_ALIGN_$_BEGUN' => $level + 1);        # Note that we've begun something
      if (LookupValue('IN_MATH')) {                           # If we're "still" in math
        $stomach->invokeToken(T_CS('\lx@begin@inmath@text')); }
      else {
        $stomach->invokeToken(T_CS('\lx@begin@inline@math')); } } });

#======================================================================
# For inserting (non-trivial?) text while in math mode
DefConstructorI('\lx@begin@inmath@text', undef,
  "<ltx:XMText>"
    . "#body"
    . "</ltx:XMText>",
  alias        => T_MATH,
  beforeDigest => sub { $_[0]->beginMode('restricted_horizontal'); }, captureBody => 1);
DefConstructorI('\lx@end@inmath@text', undef, "",
  alias        => T_MATH,
  beforeDigest => sub { $_[0]->endMode('restricted_horizontal'); });

#======================================================================
# Effectively these are the math hooks, redefine these to do what you want with math?
DefConstructorI('\lx@begin@display@math', undef,
  "<ltx:equation>"
    . "<ltx:Math mode='display'>"
    . "<ltx:XMath>"
    . "#body"
    . "</ltx:XMath>"
    . "</ltx:Math>"
    . "</ltx:equation>",
  reversion    => Tokens(T_MATH, T_MATH),
  beforeDigest => sub { 
    $_[0]->enterHorizontal;
    $_[0]->beginMode('display_math'); },
  properties   => {mode=>'display_math'},
  captureBody  => 1);
DefConstructorI('\lx@end@display@math', undef, "",
  reversion    => Tokens(T_MATH, T_MATH),
  beforeDigest => sub { $_[0]->endMode('display_math'); });

DefConstructorI('\lx@begin@inline@math', undef,
  "<ltx:Math mode='inline'>"
    . "<ltx:XMath>"
    . "#body"
    . "</ltx:XMath>"
    . "</ltx:Math>",
  reversion    => Tokens(T_MATH),
  beforeDigest => sub {
    $_[0]->enterHorizontal;
    $_[0]->beginMode('inline_math'); },
  properties   => {mode=>'inline_math'},
  captureBody  => 1);
DefConstructorI('\\lx@end@inline@math', undef, "",
  reversion    => Tokens(T_MATH),
  beforeDigest => sub { $_[0]->endMode('inline_math'); });

#======================================================================
# Add the TeX code from the object that created this node,
# unless it has already been recorded on another node.
sub add_TeX {
  my ($document, $node, $thing) = @_;
  if ($thing) {
    local $LaTeXML::DUAL_BRANCH = 'presentation';
    my $tex = UnTeX($thing);
    $LaTeXML::DUAL_BRANCH = 'content';
    my $ctex = UnTeX($thing);
    $document->setAttribute($node, tex           => $tex);
    $document->setAttribute($node, 'content-tex' => $ctex) if $ctex ne $tex; }
  return; }

# Same as add_TeX, but add the code from the body of the object.
sub add_body_TeX {
  my ($document, $node, $thing) = @_;
  if ($thing) {
    if (defined(my $body = $thing->getProperty('body'))) {
      local $LaTeXML::DUAL_BRANCH = 'presentation';
      my $tex = UnTeX($body);
      $LaTeXML::DUAL_BRANCH = 'content';
      my $ctex = UnTeX($body);
      $document->setAttribute($node, tex           => $tex);
      $document->setAttribute($node, 'content-tex' => $ctex) if $ctex ne $tex; } }
  return; }

Tag('ltx:Math', afterClose => \&add_body_TeX);
Tag('ltx:Math', afterClose => \&cleanup_Math);

# Cleanup ltx:Math elements; particularly if they aren't "really" math.
# But record the oddity with class=ltx_markedasmath
sub cleanup_Math {
  my ($document, $mathnode) = @_;
  # If the Math ONLY contains XMath/XMText, it apparently isn't math at all!?!
  # Single token PUNCTs can also be taken out of math.
  if (!$document->findnodes('ltx:XMath/ltx:*'
        . '[local-name() != "XMText" and local-name() != "XMHint" '
        . 'and not('
        . 'local-name() = "XMTok" and (@role="PUNCT" or @role="PERIOD") '
        . 'and not(preceding-sibling::*) and not(following-sibling::*) )]', $mathnode)) {
    # So unwrap down to the contents of the XMText's.
    my @texts = ();
    foreach my $xmnode (map { $_->childNodes } $mathnode->childNodes) {
      if ($document->getNodeQName($xmnode) eq 'ltx:XMHint') {
        if (my $width = $xmnode->getAttribute('width')) {
          if (my $space = DimensionToSpaces(Glue($width))) {
            push(@texts, $space); } } }
      else {    # is XMText
        foreach my $child ($xmnode->childNodes) {
          my $t = $child->nodeType;
          if    ($t == XML_COMMENT_NODE) { }
          elsif ($t != XML_ELEMENT_NODE) {     # Make sure we've got an element
            push(@texts, ['ltx:text', { class => 'ltx_markedasmath' }, $child]); }
          else {
            $document->addClass($child, 'ltx_markedasmath');
            push(@texts, $child); } } } }
    # and replace the whole Math with the pieces
    $document->replaceTree([undef, undef, @texts], $mathnode); }
  else {    # Cleanup any remaining XMTexts
    cleanup_XMText_outer($document, $mathnode); }
  return; }

# Here's for an inverse case: when an XMText isn't "really" just text
# if it only contains an Math  ORR, a tabular with only Math in the cells?
# First case: pull it back into the math, but in an XMWrap to isolate it for parsing.
# Should we just pull any mixed text math up or only a single Math?
# For the tabular case, convert it to an XMArray.

# Note that normally, we'd do afterClose on ltx:XMText,
# but since the ltx:XMText closes before the outer ltx:Math,
# we would keep cleanup_Math from recognizing the trivial case of
# a single ltx:tabular in an equation (perverse, but people do that).
# So, we put this one on ltx:Math also, and scan for any contained XMText to fixup.

sub cleanup_XMText_outer {
  my ($document, $mathnode) = @_;
  foreach my $textnode ($document->findnodes('descendant::ltx:XMText', $mathnode)) {
    cleanup_XMText($document, $textnode); }
  return; }

sub cleanup_XMText {
  my ($document, $textnode) = @_;
  # We're really only interested in reducing nested math, right?
  # But actually also collapsing ltx:XMText/ltx:text
  # Apply "outer" simplifications: remove ltx:text or ltx:p wrappings.
  my $model = $document->getModel;
  # A single "simple" element, with a single child
  my %simple_element = ('ltx:text' => 1, 'ltx:p' => 1, 'ltx:inline-block' => 1);
  my @preserved      = (qw(yoffset xoffset));
  my @children;
  while ((@children = $textnode->childNodes) && (scalar(@children) == 1)
    && $document->findnodes('ltx:text'
        . ' | ltx:inline-block[count(*)=1]'
        . ' | ltx:p',
      $textnode)) {
    my $child = $children[0];
    $document->setNodeFont($textnode, $document->getNodeFont($child));
    foreach my $attr ($child->attributes) {    # Copy the child's attributes (should Merge!!)
      $textnode->setAttribute($attr->nodeName => $attr->getValue) unless $attr->nodeName eq 'xml:id'; }
    $document->unwrapNodes($child); }

  # Now apply a simplifying rule for nested Math
  # If the XMText contains a single Math, pull it's content up in
  if ((scalar(@children) == 1) && $document->findnodes('ltx:Math', $textnode)) {
    # Replace XMText by XMWrap/*  (this should preserve the parse?)
    $textnode = $document->renameNode($textnode, 'ltx:XMWrap');
    $document->replaceNode($children[0], map { $_->childNodes } $children[0]->childNodes); }
  # # # RISKY!!!! If SOME nodes are math...
  # # # pull the whole sequence up, unwrap the math and putting the rest back in XMText.
  # # # Even with the XMWrap, this seems to wreak havoc on parsing and structure?
  # # if($document->findnodes('ltx:Math',$textnode)){
  # #   # Replace XMText by XMWrap/*  (this should preserve the parse?)
  # #   $textnode=$document->renameNode($textnode,'ltx:XMWrap');
  # #   foreach my $child (@children){
  # #     if($model->getNodeQName($child) eq 'ltx:Math'){
  # #       $document->replaceNode($child,map($_->childNodes,$child->childNodes)); }
  # #     else {
  # #       $document->wrapNodes('ltx:XMText',$child); }}}
  # If a single tabular that ONLY(?) contains Math, turn into an XMArray
  # Well, a tabular REALLY shouldn't be in math;
  # How much math should determine the switch?
  # [will alignment attributes be lost?]
  elsif ((scalar(@children) == 1) && ($model->getNodeQName($children[0]) eq 'ltx:tabular')
## Should we ALWAYS do this, or just for some minimal amount of math???
##        && !$document->findnodes('ltx:tabular/ltx:tr/ltx:td/text()'
##                                 .' | ltx:tabular/ltx:tbody/ltx:tr/ltx:td/text()'
##                                 .' | ltx:tabular/ltx:tr/ltx:td[not(ltx:Math)]'
##                                 .' | ltx:tabular/ltx:tbody/ltx:tr/ltx:td[not(ltx:Math)]',
##                                 $textnode)
  ) {
    # First step is remove any ltx:tbody from the tabular!
    foreach my $tb ($document->findnodes('ltx:tabular/ltx:tbody', $textnode)) {
      $document->unwrapNodes($tb); }
    # Now, we can start replacing tabular=>XMArray, tr=>XMRow, td=>XMCell
    my $table = $document->renameNode($children[0], 'ltx:XMArray');
    foreach my $row ($table->childNodes) {
      $row = $document->renameNode($row, 'ltx:XMRow');
      foreach my $cell ($row->childNodes) {
        $cell = $document->renameNode($cell, 'ltx:XMCell');
        foreach my $m ($cell->childNodes) {
          if ($model->getNodeQName($m) eq 'ltx:Math') {    # Math cell, unwrap the Math/XMath layer
            $document->replaceNode($m, map { $_->childNodes } $m->childNodes); }
          else {                                           # Otherwise, wrap whatever it is in an XMText
            $document->wrapNodes('ltx:XMText', $m); }
    } } }
    # And now we don't need the XMText any more.
    foreach my $attr ($textnode->attributes) {    # Copy the child's attributes (should Merge!!)
      $table->setAttribute($attr->nodeName => $attr->getValue); }
    my $newtable = $document->unwrapNodes($textnode);
    if (my $id = $textnode->getAttribute('xml:id')) {
      $document->unRecordID($id);
      $document->recordID($id, $newtable); } }
  return; }

#======================================================================
# Scripts are a bit of a strange beast, with respect to when the arguments
# are processed, and what kind of object should be created.
#
# While scripts look like they take a normal TeX argument, they really
# take the next BOX (AFTER expansion & digestion)!  Thus, while
#   a^\frac{b}{c} and a^\mathcal{B}
# DO work in TeX, other things like
#   a^\sqrt{3} or a^\acute{b}
# DO NOT! (Hint: consider the expansions)
# Note that with
#  \def\xyz{xyz}
#   a^\xyz   =>  a^{x}yz
# So, we try to mimic, but note that our boxes don't correspond 100% to TeX's
#
# Normally, sub/super scripts should be turned into a sort of postfix operator:
# The parser will attach the script to the appropriate preceding object.
# However, there are a few special cases involving empty boxes {}.
# If the argument is an empty box $x^{}$, the whole script should just disappear.
# If the PRECEDING box is {} (in ${}^{p}$, a sort of `floating' script should be created.
# This may combine, in the parser, with the following object to generate
# a prescript.

# Remember a "safe" way to test a script Whatsit.
# Returns [ (FLOATING|POST) , (SUBSCRIPT|SUPERSCRIPT) ] or nothing
sub IsScript {
  my ($object) = @_;
  if (ref $object eq 'LaTeXML::Core::List') {
    $object = [$object->unlist]->[-1]; }
  if ((ref $object eq 'LaTeXML::Core::Whatsit')    # careful w/alias in getCSName!
    && ($object->getDefinition->getCS->getCSName =~ /^\\lx@(floating|post)@(subscript|superscript)$/)) {
    return [uc($1), uc($2)]; }
  return; }

sub doScriptpos {
  return (LookupValue('font')->getMathstyle eq 'display' ? 'mid' : 'post'); }

sub doVariablesizeOp {
  return (LookupValue('font')->getMathstyle eq 'display' ? 'display' : 'text'); }

sub scriptHandler {
  no warnings 'recursion';
  my ($stomach, $op) = @_;
  my $gullet = $stomach->getGullet;
  $gullet->skipSpaces;
  my $mode     = LookupValue('MODE');
  my $font     = LookupValue('font');
  my $style    = $font->getMathstyle;
  my @putback  = ();
  my $nscripts = 0;

  if (defined $style) {
    my $cs = '\lx@floating@' . lc($op);
    my ($prevscript, $prevspace, $base);
    # Check preceding boxes to determine possible attachment (floating vs post),
    # Note that this analysis has to be done now (or sometime like it) before grouping lists go away;
    # and whether there are conflicting preceding scripts, which is an error
    # Parsing is too late!
    while (my $prev = pop(@LaTeXML::LIST)) {
      if (($prev->getProperty('isSpace'))
        || ($prev->getProperty('isEmpty'))              # EXPLICITLY empty, rather than {}
        || (ref $prev eq 'LaTeXML::Core::Comment')) {
        $prevspace = 1;              # a space avoids double-scripts
        unshift(@putback, $prev);    # put back? assuming it will add rpadding to previous???
        next; }
      elsif (IsEmpty($prev)) {       # If empty, the script floats, can't conflict, but don't put back
        last; }
      elsif (my $prevop = IsScript($prev)) {
        unshift(@putback, $prev);
        if ($$prevop[1] eq $op) {    # Whoops, duplicated; better use FLOATING
          Error('unexpected', "double-" . lc($$prevop[1]), $stomach, "Double " . lc($$prevop[1]))
            unless $prevspace;
          $cs = '\lx@floating@' . lc($op);
          last; }
        else {                       # Else, is OK (so far) assume POST (it will stack previous script)
          $prevscript = $prev;                     # we'll overlap the width of the previous.
          $cs         = '\lx@post@' . lc($op); }
        # if we hit a FLOATING script, terminate, as the floating empty group avoids double scripts
        last if ($$prevop[0] eq 'FLOATING');
        last if ++$nscripts > 1; }
      else {
        # We found something "normal", so assume we'll attach to it, and we're done.
        $base = $prev;
        unshift(@putback, $prev);
        $cs = '\lx@post@' . lc($op);
        last; } }
    push(@LaTeXML::LIST, @putback);

    MergeFont(scripted => 1);
    # Now, get following boxes (may have to process several tokens!)
    my @stuff = ();
    while (my $tok = $gullet->readXToken(0)) {
      @stuff = $stomach->invokeToken($tok);
      last if @stuff; }
    if (!@stuff) {
      Error('expected', '{', $stomach, "Missing sub/superscript argument", $gullet->showUnexpected);
      push(@stuff, Box()); }
    my $script = shift(@stuff);    # ONLY the first box is the script!
    unshift(@stuff,
      LaTeXML::Core::Whatsit->new(LookupDefinition(T_CS($cs)), [$script],
        locator     => $gullet->getLocator,
        font        => $script->getFont, isMath => 1, mode => $mode,
        level       => $stomach->getBoxingLevel,
        scriptlevel => $stomach->getScriptLevel,
        base        => $base,                      # for sizing/positioning
        prevscript  => $prevscript))
      unless IsEmpty($script);
    AssignValue(font => $font);                    # revert
    return @stuff; }
  else {                                           # Non math use of _ ??
    my $c = (($op eq 'SUPERSCRIPT') ? '^' : '_');
    Error('unexpected', $c, $stomach, "Script $c can only appear in math mode");
    return Box($c, undef, undef, (($op eq 'SUPERSCRIPT') ? T_SUPER : T_SUB));
} }

DefPrimitiveI(T_SUPER, undef, sub { scriptHandler($_[0], 'SUPERSCRIPT'); });
DefPrimitiveI(T_SUB,   undef, sub { scriptHandler($_[0], 'SUBSCRIPT'); });

# The `argument' to a sub or superscript will typically be processed as a box,
# and either has braces, or is something that results in a single box.
# When we revert these, we DON'T want to wrap extra braces around, because they'll accumulate;
# at the least they're ugly; in some applications they affect "round trip" processing.
# OTOH, direct use of \lx@post@superscript, etal, MAY need to have extra braces around them.
# So, when reverting, we're going to a bit of extra trouble to make sure we have ONE set
# of braces, but no extras!!
sub revertScript {
  my ($script) = @_;
  # We need to handle lists of lists, see arXiv:2210.11051
  my @tokens = Tokens($script->revert)->unlist;
  my @t      = @tokens;
  my $l;
  if ($t[0]->defined_as(T_BEGIN)) {
    $l++; shift(@t); }
  while (@t && $l) {
    my $t = shift(@t);
    if    ($t->defined_as(T_BEGIN)) { $l++; }
    elsif ($t->defined_as(T_END))   { $l--; } }
  return (@tokens && !@t ? @tokens : (T_BEGIN, @tokens, T_END)); }

# Compute the 'advance' of this script.
# can we do this before parsing? we can do the advance or something.... Hmmmm.
# * Need to know scriptpos (mid or post) to determine position.
# * need to know sub/super
# NOTE the following flaws:
#  * we haven't detected cramped
#  * subscript needs to shift down if superscript (rule 18e)
#  * should italic correction be omitted in deep subscripts?
sub scriptSizer {
  my ($script, $base, $prev, $op, $pos) = @_;
  my $bfont  = $base   && $base->getFont;
  my $style  = $base   && $bfont->getMathstyle || 'text';
  my $syfont = 'cmsy'.($bfont && $bfont->getSize || 10);
  my ($ws, $hs, $ds) = map { $_->valueOf } $script->getSize;
  my ($wb, $hb, $db) = map { $_->valueOf } ($base ? $base->getSize
    : LookupValue('font')->getNominalSize);
  my ($w, $h, $d) = (0, 0, 0);
  # Fishing for the scriptpos on the base (if any)
  $pos = $base->getProperty('scriptpos') if !defined $pos && defined $base;
  $pos = 'post'                          if !defined $pos;
  if ($pos eq 'mid') {
    $w = max(0, $ws - $wb);    # as if max width of base & script
    if ($op eq 'SUPERSCRIPT') {
      $h = $hb + $ds + $hs; }
    else {
      $d = $db + $hs + $ds; } }
  else {
    my $wp = ($prev && $prev->getWidth) || 0;    # as if max of width & prev script's width
    my $xheight  = getFontDimen($syfont, 5);
    my $space    = LookupRegister('\scriptspace')->valueOf;
    $ws += $space;
    $w = max(0, $ws - $wp);
    if ($op eq 'SUPERSCRIPT') {
      my $supshift = getFontDimen($syfont, # displaystyle:13, cramped:15, else 14;
        ($style eq 'display' ? 13 : ($style eq 'scriptscript' ? 15 : 14)));
      $h = max($hb, $hs + max($ds + $xheight/4, $supshift)); }
    else {
      my $subshift = getFontDimen($syfont, 16);
      $d = max($db, $ds + max($hs - $xheight*0.8, $subshift)); } }
  $w = Dimension($w); $h = Dimension($h); $d = Dimension($d);
  return ($w, $h, $d); }

# NOTE: The When reverting these, the
DefConstructor('\lx@post@superscript InScriptStyle',
  "<ltx:XMApp role='POSTSUPERSCRIPT' scriptpos='?#scriptpos(#scriptpos)(#scriptlevel)'>"
    . "<ltx:XMArg rule='Superscript'>#1</ltx:XMArg>"
    . "</ltx:XMApp>",
  reversion => sub { (T_SUPER, revertScript($_[1])); },
  sizer     => sub { scriptSizer($_[0]->getArg(1), $_[0]->getProperty('base'),
      $_[0]->getProperty('prevscript'), 'SUPERSCRIPT', 'post'); });
DefConstructor('\lx@post@subscript InScriptStyle',
  "<ltx:XMApp role='POSTSUBSCRIPT' scriptpos='?#scriptpos(#scriptpos)(#scriptlevel)'>"
    . "<ltx:XMArg rule='Subscript'>#1</ltx:XMArg>"
    . "</ltx:XMApp>",
  reversion => sub { (T_SUB, revertScript($_[1])); },
  sizer     => sub { scriptSizer($_[0]->getArg(1), $_[0]->getProperty('base'),
      $_[0]->getProperty('prevscript'),
      'SUBSCRIPT', 'post'); });
DefConstructor('\lx@floating@superscript InScriptStyle',
  "<ltx:XMApp role='FLOATSUPERSCRIPT' scriptpos='?#scriptpos(#scriptpos)(#scriptlevel)'>"
    . "<ltx:XMArg rule='Superscript'>#1</ltx:XMArg>"
    . "</ltx:XMApp>",
  reversion => sub { (T_BEGIN, T_END, T_SUPER, revertScript($_[1])); },
  sizer     => sub { scriptSizer($_[0]->getArg(1), undef, undef, 'SUPERSCRIPT', 'post'); });
DefConstructor('\lx@floating@subscript InScriptStyle',
  "<ltx:XMApp role='FLOATSUBSCRIPT' scriptpos='?#scriptpos(#scriptpos)(#scriptlevel)'>"
    . "<ltx:XMArg rule='Subscript'>#1</ltx:XMArg>"
    . "</ltx:XMApp>",
  reversion => sub { (T_BEGIN, T_END, T_SUB, revertScript($_[1])); },
  sizer     => sub { scriptSizer($_[0]->getArg(1), undef, undef, 'SUBSCRIPT', 'post'); });

# Experiment: When we detect a math element containing solely a floating superscript in the
#             *Frontmatter* of a document, assume it is a note mark, and normalize it down to
#             plain text.
DefRewrite(xpath => 'descendant::ltx:Math[child::ltx:XMath[child::ltx:XMApp[' .
    '(@role="FLOATSUPERSCRIPT" or @role="FLOATSUBSCRIPT") and ' .
    'not(preceding-sibling::*) and not(following-sibling::*) ' .
    'and not(./*/*[not(self::ltx:XMTok)]) ]]]',
  replace => sub {
    my ($document, $math) = @_;
    # We can assume the grandchild of the XMath node is the XMArg,
    # which we need to normalize to scripted Unicode.
    if (my @xmath = element_nodes($math)) {
      if (my @xmapp = element_nodes($xmath[0])) {
        if (my @xmarg = element_nodes($xmapp[0])) {
          if (my $role = $xmapp[0]->getAttribute('role')) {
            my $text = $xmarg[0]->textContent;
            local $LaTeXML::BOX = $document->getNodeBox($xmarg[0]);
            if ($role eq 'FLOATSUPERSCRIPT') {
              $document->insertElement('ltx:sup', $text);
              return; }
            elsif ($role eq 'FLOATSUBSCRIPT') {
              $document->insertElement('ltx:sub', $text);
              return; }
    } } } }
    # should never happen, but just in case:
    Info("rewrite", "footnotemark", "Failed to find floating node in: " . $math->toString(1));
    $document->getNode->appendChild($math);
    return; });

#======================================================================
# General
#----------------------------------------------------------------------
# \everydisplay         pt holds tokens inserted at the start of every switch to display math mode.
# \everymath            pt holds tokens inserted at the start of every switch to math mode.
DefRegister('\everymath',    Tokens());
DefRegister('\everydisplay', Tokens());

#======================================================================
# Creating mathematical tokens/characters
#----------------------------------------------------------------------
# \mathchar               c  specifies a math character by giving its class, family, and font position.
# \delimiter              c  specifies a delimiter.

# \mathchardef            d  provides an alternate way to define a control sequence that returns a math character.
# \mathaccent             c  makes an accent atom from the mathchar and the following item.
# \fam                    pi if 0-15, specifies the font family of class 7 (variable) math symbols.
# \delcode                iq is -1 or the delimiter code for a character.
# \mathcode               iq holds the math character (15-bit number) for each of the 256 characters with which TeX works.

DefPrimitive('\mathchar Number', sub {
    my ($stomach, $code) = @_;
    my ($glyph, $font, $reversion, %props) = decodeMathChar($code,
      Tokens(T_CS('\mathchar'), $_[1]->revert, T_CS('\relax')));
    return Box($glyph, $font, undef, $reversion, %props); });

DefConstructor('\delimiter Number',
"?#glyph(?#isMath(<ltx:XMTok role='#role' name='#name' stretchy='#stretchy'>#glyph</ltx:XMTok>)(#glyph))",
  sizer       => '#glyph',
  afterDigest => sub {
    my ($stomach, $whatsit) = @_;
    my $n = $whatsit->getArg(1)->valueOf;
    $n = $n >> 12;    # Ignore 3 rightmost digits and treat as \mathchar
    my ($glyph, $f, $rev, %props) = decodeMathChar($n);
    $whatsit->setProperty(glyph => $glyph) if $glyph;
    $whatsit->setProperties(%props)        if %props;
    $whatsit->setProperty(font => $f)      if $glyph;
    return; });

# Almost like a register, but different...
DefPrimitive('\mathchardef Token SkipSpaces SkipMatch:=', sub {
    my ($stomach, $newcs) = @_;
    $STATE->assignMeaning($newcs, $STATE->lookupMeaning(T_CS('\relax')));    # Let w/o AfterAssignment
    my $value = $stomach->getGullet->readNumber();
    $STATE->installDefinition(LaTeXML::Core::Definition::CharDef->new($newcs, 'math', $value));
    AfterAssignment();
    return; });

DefConstructor('\mathaccent Number Digested',
"<ltx:XMApp><ltx:XMTok role='#accrole' name='#name' stretchy='#stretchy'>#glyph</ltx:XMTok><ltx:XMArg>#2</ltx:XMArg></ltx:XMApp>",
  sizer       => '#2',    # Close enough?
  afterDigest => sub {
    my ($stomach, $whatsit) = @_;
    my $n = $whatsit->getArg(1)->valueOf;
    my ($glyph, $f, $rev, %props) = decodeMathChar($n);
    my $name;
    my $acc_props = unicode_accent($glyph) || {};
    $glyph = $$acc_props{unwrapped} if $$acc_props{unwrapped};
    my $accrole = $$acc_props{role} || 'OVERACCENT';
    $name = $$acc_props{name};
    $whatsit->setProperty(glyph    => $glyph)                                  if $glyph;
    $whatsit->setProperty(font     => LookupValue('font')->specialize($glyph)) if $glyph;
    $whatsit->setProperty(accrole  => $accrole)                                if $glyph;
    $whatsit->setProperty(name     => $name)                                   if $name;
    $whatsit->setProperty(stretchy => $$acc_props{stretchy} || 'false');    # stretchy ?
    return; });

# # Only used for active math characters, so far
DefRegister('\mathcode Number', Number(0),
  getter => sub {
    my $ch   = $_[0]->valueOf;
    my $code = $STATE->lookupMathcode(chr($ch));
    Number(defined $code ? $code : $ch); },    # defaults to the char's code itself(?)
  setter => sub { $STATE->assignMathcode(chr($_[2]->valueOf) => $_[0]->valueOf, $_[1]); });
# Not used anywhere (yet)
DefRegister('\delcode Number', Number(-1),
  getter => sub { my $code = $STATE->lookupDelcode(chr($_[0]->valueOf));
    Number(defined $code ? $code : -1); },
  setter => sub { $STATE->assignDelcode(chr($_[2]->valueOf) => $_[0]->valueOf, $_[1]); });

# This probably needs work;
# Assigning should choose the font specified by \textfont,\scriptfont...
# but it should be initialized to -1 at beginning of every math!
DefRegister('\fam' => Number(-1),
  getter => sub {
    $STATE->lookupValue('fontfamily'); },
  setter => sub {
    my ($fam, $scope) = @_;
    $STATE->assignValue('fontfamily' => $fam->valueOf, $scope);
  });

#======================================================================
# TeX-level grammatical roles
#----------------------------------------------------------------------
# \mathbin                c  assigns class 2 (binary operation) to the following character or subformula.
# \mathclose              c  assigns class 5 (closing) to the following character or subformula.
# \mathinner              c  makes an inner atom holding the math field.
# \mathop                 c  assigns class 1 (large operator) to following character or subformula.
# \mathopen               c  assigns class 4 (opening) to following character or subformula.
# \mathord                c  assigns class 0 (ordinary) to following character or subformula.
# \mathpunct              c  assigns class 6 (punctuation) to following character or subformula.
# \mathrel                c  assigns class 3 (relation) to following character or subformula.

# Add an XMWrap, adjusting the math role unless it's already a sub-class of the requested coarse TeX math classes
# Is XMWrap the right thing to wrap with (instead of XMArg)?
our %mathclass_subclass = (
  BIGOP => { ARROW => 1, SUMOP => 1, INTOP => 1, DIFFOP => 1 },
  BINOP => { ADDOP => 1, MULOP => 1 },
  RELOP => {},
  OPEN  => {},
  CLOSE => {},
  PUNCT => { PERIOD => 1 },
  ID    => { NUMBER => 1 },
  ATOM  => {},    # really any role
);

sub adjustMathRole {
  my ($role, $document, $node, %props) = @_;
  if (!$node) { }    # Nothing? do nothing!
  else {
    my $wrapper = $document->openElement('ltx:XMWrap');
    $document->absorb($node);
    $document->closeElement('ltx:XMWrap');
    my @nodes = element_nodes($wrapper);
    @nodes = grep { $document->getNodeQName($_) ne 'ltx:XMHint'; } @nodes;
    my $applied = 0;
    my $gotrole = '';
    if ((scalar(@nodes) == 1)    # Got single node
      && ($gotrole = $nodes[0]->getAttribute('role'))                        # with a role
      && (($role eq 'ATOM') || $mathclass_subclass{$role}{$gotrole})) { }    # and acceptable? Do nothing
    else {
      $applied = 1;
      $wrapper->setAttribute(role => $role); }    # Else, assign the requested role
    $wrapper->setAttribute(scriptpos => $props{scriptpos}) if defined $props{scriptpos};
    $wrapper->setAttribute(mathstyle => $props{mathstyle}) if defined $props{mathstyle}; }
  return; }
DefConstructor('\mathord Digested', sub { adjustMathRole('ID', @_); });
DefConstructor('\mathop Digested', sub { adjustMathRole('BIGOP', @_); },
  properties => { scriptpos => \&doScriptpos });
DefConstructor('\mathbin Digested',   sub { adjustMathRole('BINOP', @_); });
DefConstructor('\mathrel Digested',   sub { adjustMathRole('RELOP', @_); });
DefConstructor('\mathopen Digested',  sub { adjustMathRole('OPEN',  @_); });
DefConstructor('\mathclose Digested', sub { adjustMathRole('CLOSE', @_); });
DefConstructor('\mathpunct Digested', sub { adjustMathRole('PUNCT', @_); });
DefConstructor('\mathinner Digested', sub { adjustMathRole('ATOM',  @_); });

#======================================================================
# Delimiters
#----------------------------------------------------------------------
# \left     c  makes TeX calculate the size of the delimiter needed at the left of a subformula.
# \right    c  makes TeX calculate the size of the delimiter needed at the right of a subformula.

# Read a Delimiter, for \left,\right, but also \big, etc
# Formally a delimiter is either a token, or \delimiter<number> or maybe \radical<number>,
# but we don't actually restrict to those.
# Note that \big expands into \left, unwrapping {} once; only the first atom gets big.
DefParameterType('TeXDelimiter', sub {
  no warnings 'recursion';
  my ($gullet) = @_;
  $gullet->skipFiller;          # Skip spaces and \relax
  my $token = $gullet->readXToken(0);
  if ($token && $token->getCatcode == CC_BEGIN) { # Unwrap once; re-read token
    $gullet->unread($gullet->readBalanced(1));
    $gullet->skipFiller;
    $token = $gullet->readXToken(0); }
  # Replace "." by special hint.
  $token = T_CS('\lx@delimiterdot') if (! defined $token) || (ToString($token) eq '.');
  my ($delim) = $STATE->getStomach->invokeToken($token);
  return $delim; },
  undigested => 1,                         # since _already_ digested.
  reversion  => sub { Revert($_[0]); });   # shouldn't need braces

DefConstructor('\lx@delimiterdot', "<ltx:XMHint/>",
  alias => '.',
  properties => {hint => 1});

# This duplicates in slightly different way what DefMath has put together.
# [duplication seems like a bad idea!]
# This should ultimately be part of some set of Unicode tables.
our %DELIMITER_MAP =
  ('(' => { lrole => 'OPEN', rrole => 'CLOSE' },
  ')'        => { lrole => 'OPEN', rrole => 'CLOSE' },
  '['        => { lrole => 'OPEN', rrole => 'CLOSE' },
  ']'        => { lrole => 'OPEN', rrole => 'CLOSE' },
  '{'        => { lrole => 'OPEN', rrole => 'CLOSE' },
  '}'        => { lrole => 'OPEN', rrole => 'CLOSE' },
  "\x{230A}" => { lrole => 'OPEN', rrole => 'CLOSE', name => 'lfloor' },
  "\x{230B}" => { lrole => 'OPEN', rrole => 'CLOSE', name => 'rfloor' },
  "\x{2308}" => { lrole => 'OPEN', rrole => 'CLOSE', name => 'lceil' },
  "\x{2309}" => { lrole => 'OPEN', rrole => 'CLOSE', name => 'rceil' },
  "\x{27E8}" => { lrole => 'OPEN', rrole => 'CLOSE', name => 'langle' },
  "\x{27E9}" => { lrole => 'OPEN', rrole => 'CLOSE', name => 'rangle' },
  '<'        => { lrole => 'OPEN', rrole => 'CLOSE', name => 'langle',
    char => "\x{27E8}", meaning => undef },
  '>' => { lrole => 'OPEN', rrole => 'CLOSE', name => 'rangle',
    char => "\x{27E9}", meaning => undef },
  '/'        => { lrole => 'MULOP',   rrole => 'MULOP' },
  UTF(0x5C)  => { lrole => 'MULOP',   rrole => 'MULOP', name => 'backslash' },
  '|'        => { lrole => 'VERTBAR', rrole => 'VERTBAR' },
  "\x{2225}" => { lrole => 'VERTBAR', rrole => 'VERTBAR' },
  "\x{2191}" => { lrole => 'OPEN',    rrole => 'CLOSE', name => 'uparrow' },        # ??
  "\x{21D1}" => { lrole => 'OPEN',    rrole => 'CLOSE', name => 'Uparrow' },        # ??
  "\x{2193}" => { lrole => 'OPEN',    rrole => 'CLOSE', name => 'downarrow' },      # ??
  "\x{21D3}" => { lrole => 'OPEN',    rrole => 'CLOSE', name => 'Downarrow' },      # ??
  "\x{2195}" => { lrole => 'OPEN',    rrole => 'CLOSE', name => 'updownarrow' },    # ??
  "\x{21D5}" => { lrole => 'OPEN',    rrole => 'CLOSE', name => 'Updownarrow' },    # ??
  );

# The \lx@left, \lx@right versions are like \left,\right but without any extra grouping
DefConstructor('\lx@left TeXDelimiter', "#1",
  afterConstruct => sub { augmentDelimiterProperties($_[0], $_[1], 'OPEN', 1); },
  alias          => '\left');

DefConstructor('\lx@right TeXDelimiter', "#1",
  afterConstruct => sub { augmentDelimiterProperties($_[0], $_[1], 'CLOSE', 1); },
  alias          => '\right');

# This is a little messier than you'd think.
# These effectively create a (boxing) group BETWEEN the \left,\right. (but should be hidden)
# But you have to digest \left's delimiter before you can start the {...} group!
DefConstructor('\left TeXDelimiter', "#1",
  afterDigest => sub { my ($stomach, $whatsit) = @_;
    $stomach->getGullet->unread(T_CS('\lx@hidden@bgroup'));
    return; },
  afterConstruct => sub { augmentDelimiterProperties($_[0], $_[1], 'OPEN', 1); });

DefMacro('\right', '\lx@hidden@egroup@right\lx@right');

# \lx@hidden@egroup@right tries to manage unbalanced {} errors, if an \left was forgotten.
DefConstructor('\lx@hidden@egroup@right', '',
  afterDigest => sub {
    my ($stomach) = @_;
    if ($STATE->isValueBound('MODE', 0)    # Last stack frame was a mode switch!?!?!
      || $STATE->lookupValue('groupNonBoxing')) {    # or group was opened with \begingroup
      Error('unexpected', '\right', undef, "Unbalanced \\right, no balancing \\left."); }
    else {
      $stomach->egroup; } },
  reversion => '');

# Add delimiter relevant attributes to the current token
sub augmentDelimiterProperties {
  my ($document, $whatsit, $role, $stretchy) = @_;
  my $current = $document->getNode;
  my $delim   = $document->getLastChildElement($current) || $current;
  my $char    = $delim && $delim->textContent;
  $document->setNodeBox($delim, $whatsit);
  if (! $whatsit->getProperty('hint')
      && $delim && ($delim->nodeType == XML_ELEMENT_NODE)) {
    $delim->setAttribute(stretchy => 'true') if $stretchy;
    if (my $entry = $DELIMITER_MAP{$char}) {
      my $newrole = $role && $$entry{ ($role eq 'OPEN' ? 'lrole' : 'rrole') } || $role;
      $delim->setAttribute(role => $newrole) if $newrole;
      $delim->setAttribute(name => $$entry{name}) if $$entry{name};
      if (exists $$entry{meaning}) {
        if (my $meaning = $$entry{meaning}) {
          $delim->setAttribute(meaning => $meaning); }
        else {
          $delim->removeAttribute('meaning'); } }    # RETRACT any assumed meaning
      if (exists $$entry{char}) {                    # replace the char content!
        if (my $char = $$entry{char}) {
          $delim->firstChild->setData($char); } }
    } }
  return; }

# Useful for afterConstruct of delimiter sizing macros (eg. \bigl)
sub addDelimiterRole {
  my ($document, $role) = @_;
  my $current = $document->getNode;
  my $delim   = $document->getLastChildElement($current) || $current;
  my $delim_role = (($delim && ($delim->nodeType == XML_ELEMENT_NODE) && $delim->getAttribute('role')) || '<none>');
  # if there is some delimiter-like role on the "delimiter", switch it, otherwise, leave it alone!
  if ($delim && ($delim_role =~ /^(OPEN|MIDDLE|CLOSE|VERTBAR|<none>)$/)) {
    ## Maybe we shouldn't switch VERTBAR ?
    ## The catch is that occasionally people use a single \Bigl (or whatever)
    ## where they should have used a \Big
    $document->setAttribute($delim, role => $role); }
  return; }

#======================================================================
# Limit placement
#----------------------------------------------------------------------
# \limits                 c  displays limits above and below large operators (class 1).
# \nolimits               c  displays limits to the right of large operators (class 1).
# \displaylimits          c  restores normal conventions for using limits with operators.

DefConstructorI('\limits', undef, '',
  afterDigest => sub { mergeLimits('mid'); },
  properties  => { isEmpty => 1 });
DefConstructorI('\nolimits', undef, '',
  afterDigest => sub { mergeLimits('post'); },
  properties  => { isEmpty => 1 });
DefConstructorI('\displaylimits', undef, '',
  afterDigest => sub {
    mergeLimits((($_[1]->getProperty('mathstyle') || '') eq 'display' ? 'mid' : 'post')); },
  properties => { isEmpty => 1 });

sub mergeLimits {
  my ($pos) = @_;
  for (my $i = scalar(@LaTeXML::LIST) - 1 ; $i >= 0 ; $i--) {
    my $box   = $LaTeXML::LIST[$i];
    my $prev  = $box->getProperty('scriptpos') || '';
    my $level = ($prev =~ /^\w*(\d+)$/ ? $1 : $STATE->getStomach->getScriptLevel || '');
    $box->setProperty(scriptpos => $pos . $level);
    last unless IsEmpty($box) || IsScript($box); }
  return; }

#======================================================================
# Math script fonts
#----------------------------------------------------------------------
# \textfont               iq specifies the text font for a family.
# \scriptfont             iq specifies the script font for a family.
# \scriptscriptfont       iq specifies the scriptscript font for a family.

# Doubtful that we can do anything useful with these.
# These look essentially like Registers, although Knuth doesn't call them that.
# NOTE: These should just point to a CS token, right????
# (although it SHOULD be one defined to be a font switch??)
# NOTE: These should NOT be global(?)
DefRegister('\textfont Number' => T_CS('\tenrm'),
  getter => sub {
    my ($fam) = @_;
    LookupValue('textfont_' . $fam->valueOf); },
  setter => sub {
    my ($font, $scope, $fam) = @_;
    AssignValue('textfont_' . $fam->valueOf => $font, $scope); });
DefRegister('\scriptfont Number' => T_CS('\sevenrm'),
  getter => sub {
    my ($fam) = @_;
    LookupValue('scriptfont_' . $fam->valueOf); },
  setter => sub {
    my ($font, $scope, $fam) = @_;
    AssignValue('scriptfont_' . $fam->valueOf => $font, $scope); });
DefRegister('\scriptscriptfont Number' => T_CS('\fiverm'),
  getter => sub {
    my ($fam) = @_;
    LookupValue('scriptscriptfont_' . $fam->valueOf); },
  setter => sub {
    my ($font, $scope, $fam) = @_;
    AssignValue('scriptscriptfont_' . $fam->valueOf => $font, $scope); });

#======================================================================
# Math script styles
#----------------------------------------------------------------------
# \displaystyle           c  selects display style: D or D'.
# \scriptscriptstyle      c  selects scriptscript style: SS or SS'.
# \scriptstyle            c  selects script style: S or S'.
# \textstyle              c  selects text style: T or T'.

# Also record that this explicitly sets the mathstyle (support for \over, etal)
DefPrimitiveI('\displaystyle', undef, sub {
    MergeFont(mathstyle => 'display');
    Box(undef, undef, undef, T_CS('\displaystyle'), explicit_mathstyle => 1); });
DefPrimitiveI('\textstyle', undef, sub {
    MergeFont(mathstyle => 'text');
    Box(undef, undef, undef, T_CS('\textstyle'), explicit_mathstyle => 1); });
DefPrimitiveI('\scriptstyle', undef, sub {
    MergeFont(mathstyle => 'script');
    Box(undef, undef, undef, T_CS('\scriptstyle'), explicit_mathstyle => 1); });
DefPrimitiveI('\scriptscriptstyle', undef, sub {
    MergeFont(mathstyle => 'scriptscript');
    Box(undef, undef, undef, T_CS('\scriptscriptstyle'), explicit_mathstyle => 1); });

#======================================================================
#
#----------------------------------------------------------------------
# \mathchoice             c  specifies specific subformulas for the 4 main styles.
# \vcenter                c  centers material with respect to the axis.

# Note that in TeX, all 4 args get digested(!)
# and the choice is made when absorbing!
DefConstructor('\mathchoice Digested Digested Digested Digested', sub {
    my ($document, $d, $t, $s, $ss, %props) = @_;
    my $style  = $props{mathstyle};
    my $choice = ($style eq 'display' ? $d
      : ($style eq 'text' ? $t
        : ($style eq 'script' ? $s
          : $ss)));
    $document->absorb($choice); },
  properties => { mathstyle => sub { LookupValue('font')->getMathstyle; } });

# THIS IS WRONG!!!!
Let('\vcenter', '\vbox');

#======================================================================
#
#----------------------------------------------------------------------
# \overline               c  puts a line over the following character or subformula.
# \underline              c  puts a line under the following character or subformula.

# Note that (over|under) brace accents act like \limit, but lines, arrows do NOT!
DefMath('\lx@math@overline{}', UTF(0xAF),
  operator_role => 'OVERACCENT', operator_stretchy => 'true',
  name          => 'overline',   alias             => '\overline');
DefConstructor('\lx@text@overline{}',
  "<ltx:text framed='overline' _noautoclose='1'>#1</ltx:text>",
  enterHorizontal => 1);
DefMath('\lx@math@underline{}', UTF(0xAF),
  operator_role => 'UNDERACCENT', operator_stretchy => 'true',
  name          => 'underline',   alias             => '\underline');
DefConstructor('\lx@text@underline{}',
  "<ltx:text framed='underline' _noautoclose='1'>#1</ltx:text>",
  enterHorizontal => 1);
DefMath('\lx@math@overrightarrow{}', "\x{2192}",
  operator_role => 'OVERACCENT',     operator_stretchy => 'true',
  name          => 'overrightarrow', alias             => '\overrightarrow');
DefMath('\lx@math@overleftarrow{}', "\x{2190}",
  operator_role => 'OVERACCENT',    operator_stretchy => 'true',
  name          => 'overleftarrow', alias             => '\overleftarrow');
DefMath('\lx@math@underrightarrow{}', "\x{2192}",
  operator_role => 'UNDERACCENT',     operator_stretchy => 'true',
  name          => 'underrightarrow', alias             => '\underrightarrow');
DefMath('\lx@math@underleftarrow{}', "\x{2190}",
  operator_role => 'UNDERACCENT',    operator_stretchy => 'true',
  name          => 'underleftarrow', alias             => '\underleftarrow');
DefMath('\lx@math@overbrace{}', "\x{23DE}",
  operator_role => 'OVERACCENT', scriptpos => 'mid',        operator_stretchy => 'true',
  name          => 'overbrace',  alias     => '\overbrace', robust            => 1);
DefMath('\lx@math@underbrace{}', "\x{23DF}",
  operator_role => 'UNDERACCENT', scriptpos => 'mid',         operator_stretchy => 'true',
  name          => 'underbrace',  alias     => '\underbrace', robust            => 1);

# Careful: Use \protect so that it doesn't expand too early in alignments, etc.
# [Really shouldn't use \protect, since this is a TeX primitive and \protect is LaTeX]
DefMacro('\overline{}', '\protect\ifmmode\lx@math@overline{#1}\else\lx@text@overline{#1}\fi',
  locked => 1);
DefMacro('\underline{}', '\protect\ifmmode\lx@math@underline{#1}\else\lx@text@underline{#1}\fi',
  locked => 1);

#======================================================================
# fraction-like things
#----------------------------------------------------------------------
# \above                  d  is equivalent to `\abovewithdelims..'.
# \abovewithdelims        c  is a generalized fraction command.
# \atop                   d  is equivalent to `\atopwithdelims..'.
# \atopwithdelims         d  is a generalized fraction command with an invisible fraction bar.
# \over                   d  is equivalent to `\overwithdelims..'.
# \overwithdelims         d  is a generalized fraction command with preset fraction bar thickness.
# After digesting the \choose (or whatever), grab the previous and following material
# and store as args in the whatsit.

# Increment the mathstyle stored in any boxes & whatsits.
# The tricky part is to know when NOT to increment!
# \displaystyle, constructors that set their own specific style,...
# And, any collateral adjustments that had been done in digestion depending on mathstyle
# WONT be adjusted!
# We don't have a clear API to find the displayable Boxes within;
# and we don't have a good handle on grouping...

# ARGH!!!!!!!!! RETHINK!!!!!!
sub adjustMathstyle {
  my ($outerstyle, $adjusted, @boxes) = @_;
  foreach my $box (@boxes) {
    next unless defined $box;
    next if $$adjusted{$box};    # since we do args AND props, be careful not to adjust twice!
    $$adjusted{$box} = 1;
    my $r = ref $box;
    next unless $r && ($r !~ /(?:SCALAR|HASH|ARRAY|CODE|REF|GLOB|LVALUE)/) && $r->isaBox;
    return if $box->getProperty('explicit_mathstyle');
    next   if $box->getProperty('own_mathstyle');

    if ($r eq 'LaTeXML::Core::Box') {
      adjustMathStyle_internal($outerstyle, $box); }
    elsif ($r eq 'LaTeXML::Core::List') {
      adjustMathstyle($outerstyle, $adjusted, $box->unlist); }
    elsif ($r eq 'LaTeXML::Core::Whatsit') {
      my $style = adjustMathStyle_internal($outerstyle, $box) || $outerstyle;
      # now recurse on contained boxes (args AND properties!)
      adjustMathstyle($style, $adjusted, $box->getArgs);
      adjustMathstyle($style, $adjusted, values %{ $box->getPropertiesRef }); } }
  return; }

# Heursitic;
# we're wanting to adjust the style AS IF the numerator had been already in the next mathstyle
# This isn't the same as just shifting the mathstyle!
# we're sorta trying to infer WHY the box has a given style...?
our %mathstyle_adjust_map = (
  display => { display => 'text', text => 'script', script => 'script', scriptscript => 'scriptscript' },
  text => { display => 'text', text => 'script', script => 'scriptscript', scriptscript => 'scriptscript' },
  script => { display => 'display', text => 'text', script => 'scriptscript', scriptscript => 'scriptscript' },
  scriptscript => { display => 'display', text => 'text', script => 'scriptscript', scriptscript => 'scriptscript' });

sub adjustMathStyle_internal {
  my ($outerstyle, $box) = @_;
  $outerstyle = 'display' unless $outerstyle;
  if (my $font = $box->getFont) {
    my $origstyle = $font->getMathstyle || 'display';
    my $newstyle  = $mathstyle_adjust_map{$outerstyle}{$origstyle};
    $box->setFont($font->merge(mathstyle => $newstyle));
    if (my $recstyle = $box->getProperty('mathstyle')) {    # And adjust here, if recorded.
      $box->setProperty(mathstyle => $newstyle);
      return $newstyle; } }
  return; }

sub fracSizer {
  my ($numerator, $denominator) = @_;
  my $w = $numerator->getWidth->larger($denominator->getWidth);
  my $d = $denominator->getTotalHeight->multiply(0.5);
  my $h = $numerator->getTotalHeight->add($d);
  return ($w, $h, $d); }

# \lx@generalized@over{reversion}{keyvals}{top}{bottom}
# keyvals: role,meaning, left,right, thickness
DefConstructor('\lx@generalized@over Undigested RequiredKeyVals',
  "?#needXMDual("
    . "<ltx:XMDual>"
    . "<ltx:XMApp>"
    . "<ltx:XMRef _xmkey='#xmkey0'/>"
    . "<ltx:XMRef _xmkey='#xmkey1'/>"
    . "<ltx:XMRef _xmkey='#xmkey2'/>"
    . "</ltx:XMApp>"
    . "<ltx:XMWrap>"
    . "#left)()"
    . "<ltx:XMApp>"
    . "<ltx:XMTok _xmkey='#xmkey0' role='#role' meaning='#meaning' mathstyle='#mathstyle' thickness='#thickness'/>"
    . "<ltx:XMArg _xmkey='#xmkey1'>#top</ltx:XMArg>"
    . "<ltx:XMArg _xmkey='#xmkey2'>#bottom</ltx:XMArg>"
    . "</ltx:XMApp>"
    . "?#needXMDual(#right"
    . "</ltx:XMWrap>"
    . "</ltx:XMDual>)()",
  afterDigest => sub {
    my ($stomach, $whatsit) = @_;
    my $kv = $whatsit->getArg(2);
    # Really, we want the mathstyle that was in effect BEFORE the group starting the numerator!
    # (there could be a \displaystyle INSIDE the numerator, but that's not the one we want)
    # Of course the group that started the numerator may be the start of the Math, itself!
    # AND, the numerator, which was already digested, needs it's mathstyle ADJUSTED
    my $font = ($STATE->isValueBound('MODE', 0)    # Last stack frame was a mode switch!?!?!
      ? $STATE->lookupValue('font')                # then just use whatever font we've got
      : ($STATE->isValueBound('font', 0)           # else if font was set in numerator
          && $STATE->valueInFrame('font', 1))
        || $STATE->lookupValue('font')             # then just use whatever font we've got
    );
    my $style     = $font->getMathstyle;
    my $role      = ToString($kv->getValue('role'));
    my $meaning   = ToString($kv->getValue('meaning'));
    my $thickness = ToString($kv->getValue('thickness'));
    $role    = 'FRACOP' unless $role;
    $meaning = 'divide' if (!$meaning) && ($thickness ne '0pt');
    # Unfortunately, the numerator's already digested! We have to adjust it's mathstyle
    my @top = $stomach->regurgitate;
    # really have to pass +/-1, +/-2 etc..!
    adjustMathstyle($style, {}, @top);
    MergeFont(fraction => 1);
    my @bot     = $stomach->digestNextBody();
    my $closing = pop(@bot);    # We'll leave whatever closed the list (endmath, endgroup...)
    $whatsit->setProperties(
      top       => List(@top, mode => 'math'),
      bottom    => List(@bot, mode => 'math'),
      role      => $role,
      meaning   => $meaning,
      thickness => $thickness,
      mathstyle => $style);
    if ($kv->getValue('left') || $kv->getValue('right')) {
      $whatsit->setProperties(needXMDual => 1,
        xmkey0 => LaTeXML::Package::getXMArgID(),
        xmkey1 => LaTeXML::Package::getXMArgID(),
        xmkey2 => LaTeXML::Package::getXMArgID()); }
    return $closing; },    # and leave the closing bit, whatever it is.
  properties => sub { %{ $_[2]->getKeyVals }; },
  sizer      => sub { fracSizer($_[0]->getProperty('top'), $_[0]->getProperty('bottom')); },
  reversion  => sub {
    my ($whatsit) = @_;
    (Revert($whatsit->getProperty('top')),
      $whatsit->getArg(1)->unlist,
      Revert($whatsit->getProperty('bottom'))); });

DefMacro('\above Dimension',
  '\lx@generalized@over{\above #1}{meaning=divide,thickness=#1}');
DefMacro('\abovewithdelims Token Token Dimension',
'\lx@generalized@over{\abovewithdelims #1 #2 #3}{left={\lx@left#1},right={\lx@right#2},meaning=divide,thickness=#3}');
DefMacro('\atop',
  '\lx@generalized@over{\atop}{thickness=0pt}');
DefMacro('\atopwithdelims Token Token',
  '\lx@generalized@over{\atopwithdelims #1 #2}{thickness=0pt,left={\lx@left#1},right={\lx@right#2}}');
DefMacro('\over',
  '\lx@generalized@over{\over}{meaning=divide}');
DefMacro('\overwithdelims Token Token',
'\lx@generalized@over{\overwithdelims #1 #2}{left={\lx@left#1},right={\lx@right#2},meaning=divide}');
# My thinking was that this is a "fraction" providing the dimension is > 0!

#======================================================================
#
#----------------------------------------------------------------------
# \mkern                  c  adds a math kern item to the current math list.
# \mskip                  c  adds math glue to the current math list.
# \thinmuskip             pm is ``thin'' math glue inserted into formulas.
# \medmuskip              pm is ``medium'' math glue inserted into formulas.
# \thickmuskip            pm is ``thick'' math glue inserted into formulas.
# \abovedisplayskip       pg is normal glue placed before a displayed equation.
# \abovedisplayshortskip  pg is alternate glue placed before a displayed equation.
# \belowdisplayskip       pg is normal glue placed after a displayed equation.
# \belowdisplayshortskip  pg is alternate glue placed after a displayed equation.

DefPrimitive('\mkern MuGlue', sub {
    my ($stomach, $length) = @_;
    my $s = DimensionToSpaces($length);
    Box($s, undef, undef, Invocation(T_CS('\mkern'), $length),
      width => $length, isSpace => 1); });

DefPrimitive('\mskip MuGlue', sub {
    my ($stomach, $length) = @_;
    my $s = DimensionToSpaces($length);
    Box($s, undef, undef, Invocation(T_CS('\mskip'), $length),
      width => $length, isSpace => 1); });

# MuGlue registers; TeXBook p.274
DefRegister('\thinmuskip'  => MuGlue("3mu"));
DefRegister('\medmuskip'   => MuGlue("4mu plus 2mu minus 4mu"));
DefRegister('\thickmuskip' => MuGlue("5mu plus 5mu"));

DefRegister('\abovedisplayskip'      => Glue('12pt plus 3pt minus 9pt'));
DefRegister('\abovedisplayshortskip' => Glue('0pt plus 3pt'));
DefRegister('\belowdisplayskip'      => Glue('12pt plus 3pt minus 9pt'));
DefRegister('\belowdisplayshortskip' => Glue('0pt plus 3pt'));

#======================================================================
#
#----------------------------------------------------------------------
# \binoppenalty           pi is the penalty for a line break after a binary operation.
# \postdisplaypenalty     pi is the penalty added immediately after a math display.
# \predisplaypenalty      pi is the penalty added immediately before a math display.
# \relpenalty             pi is the penalty for a line break after a relation.
# \displaywidowpenalty    pi is the penalty added after the penultimate line immediately preceeding a display.
# \skewchar               iq is -1 or the character used to fine-tune the positioning of math accents     .
# \defaultskewchar        pi is -1 or the \skewchar value for a font when it is loaded.
# \delimitershortfall     pd is the second parameter used to compute the size of delimeters required by \left and \right.
# \displayindent          pd is the amount to shift a line holding a displayed equation.
# \displaywidth           pd is the width of the line holding a displayed equation.
# \mathsurround           pd is extra space added when switching in and out of math mode.
# \nulldelimiterspace     pd is the width of a null or missing delimiter.
# \predisplaysize         pd is the effective width of the line preceeding a displayed equation.
# \scriptspace            pd is extra space added after a subscript or a superscript.
# \delimiterfactor        pi is the first parameter used to compute the size of delimeters required by \left and \right.

DefRegister('\binoppenalty'        => Number(700));
DefRegister('\relpenalty'          => Number(500));
DefRegister('\displaywidowpenalty' => Number(50));
DefRegister('\predisplaypenalty'   => Number(10000));
DefRegister('\postdisplaypenalty'  => Number(0));

DefRegister('\skewchar FontDef' => Number(0),
  getter => sub {
    my ($fontinfo) = @_;
    return ($fontinfo && $$fontinfo{skewchar}) || Number(0); },
  setter => sub {
    my ($value, $scope, $fontinfo) = @_;
    if ($fontinfo) {
      $$fontinfo{skewchar} = $value; } }
);

DefRegister('\defaultskewchar' => Number(-1));

# Dimen registers; TeXBook p. 274
DefRegister('\delimitershortfall' => Dimension('5pt'));
DefRegister('\nulldelimiterspace' => Dimension('1.2pt'));
DefRegister('\scriptspace'        => Dimension('0.5pt'));
DefRegister('\mathsurround'       => Dimension(0));
DefRegister('\predisplaysize'     => Dimension(0));
DefRegister('\displaywidth'       => Dimension(0));
DefRegister('\displayindent'      => Dimension(0));
DefRegister('\delimiterfactor'    => Number(0));

#======================================================================
# Equation numbers
#----------------------------------------------------------------------
# \eqno                   c  puts an equation number at the right-hand margin.
# \leqno                  c  puts an equation number at the left-hand margin.

# \eqno & \leqno are really bizzare.
# They should seemingly digest until $ (or while still in math mode),
# and use that stuff as the reference number.
# However, since people abuse this, and we're really not quite TeX,
# we really can't do it Right.
# Even a \begin{array} ends up expanding into a $ !!!
DefMacroI('\eqno', undef, sub {
    my ($gullet) = @_;
    my $locator  = $gullet->getLocator;
    my @stuff    = ();
    # This is risky!!!
    while (my $t = $gullet->readXToken(0)) {
      if ($t->defined_as(T_BEGIN)) {
        push(@stuff, $t, $gullet->readBalanced, T_END); }
      # What do I need to explicitly list here!?!?!? UGGH!
      elsif ($t->defined_as(T_MATH)
        || $t->defined_as(T_CS('\]'))
        # UGH from 2022: also don't jump over rows
        || $t->defined_as(T_CS('\cr'))
        # see arXiv:math/0001062, for one example
        || $t->defined_as(T_CS('\lx@hidden@cr'))
        || $t->defined_as(T_CS('\lx@end@display@math'))
        || $t->defined_as(T_CS('\begingroup'))       # Totally wrong, but to catch expanded environments
        || (ToString($t) =~ /^\\(?:begin|end)\{/)    # any sort of environ begin or end???
                                                     # This seems needed within AmSTeX environs
      ) {
        return (Invocation(T_CS('\lx@eqno'), Tokens(@stuff, T_CS('\relax'))), $t); }
      else {
        push(@stuff, $t); } }
    Error('unexpected', '\eqno', $gullet, "Fell of the end reading tag for \\eqno!",
      "started " . ToString($locator));
    return Tokens(@stuff); });

Let('\leqno', '\eqno');
# Revert to nothing, since it really doesn't belong in the TeX string(?)
DefConstructor('\lx@eqno{}',
  "^ <ltx:tags><ltx:tag><ltx:Math><ltx:XMath>#1</ltx:XMath></ltx:Math></ltx:tag></ltx:tags>",
  reversion => '');

#======================================================================
# Pretest for XMath to keep from interpreting math that the DOM may not allow!!
##DefMathRewrite(xpath=>'descendant-or-self::ltx:XMath',match=>'\cdot\cdot\cdot',replace=>'\cdots');

DefMathLigature("\x{22C5}\x{22C5}\x{22C5}" => "\x{22EF}", role => 'ID', name => 'cdots');

#DefMathRewrite(xpath=>'descendant-or-self::ltx:XMath',match=>'...',replace=>'\ldots');
DefMathLigature("..." => "\x{2026}", role => 'ID', name => 'ldots');

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
1;
