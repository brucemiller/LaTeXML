# -*- mode: Perl -*-
# /=====================================================================\ #
# |  TeX_Job                                                            | #
# | Core TeX Implementation for LaTeXML                                 | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | Bruce Miller <bruce.miller@nist.gov>                        #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #
package LaTeXML::Package::Pool;
use strict;
use warnings;
use LaTeXML::Global;
use LaTeXML::Core::Dumper;
use LaTeXML::Package;

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Job Family of primitive control sequences
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#======================================================================
# The current Job
#----------------------------------------------------------------------
# \jobname          c  is the underlying file name for a job.
# \time             pi holds the current time in minutes after midnight (0-1439).
# \day              pi holds the current day of the month (1-31).
# \month            pi holds the current month of the year (1-12).
# \year             pi holds the current year (e.g., 2000).
# \mag              pi holds the magnification ratio times 1000.

DefMacroI('\jobname', undef, Tokens());    # Set to the filename by initialization
DefRegister('\time'  => Number(0));
DefRegister('\day'   => Number(0));
DefRegister('\month' => Number(0));
DefRegister('\year'  => Number(0));
DefRegister('\mag'   => Number(1000));

# This may mess up Daemon state?
{ my ($sec, $min, $hour, $mday, $mon, $year) = defined $ENV{SOURCE_DATE_EPOCH} ? gmtime($ENV{SOURCE_DATE_EPOCH}) : localtime();
  AssignValue('\day'   => Number($mday),             'global');
  AssignValue('\month' => Number($mon + 1),          'global');
  AssignValue('\year'  => Number(1900 + $year),      'global');
  AssignValue('\time'  => Number(60 * $hour + $min), 'global'); }

our @MonthNames = (qw( January February March April May June
    July August September October November December));

# Return a string for today's date.
sub today {
  return $MonthNames[LookupValue('\month')->valueOf - 1]
    . " " . LookupValue('\day')->valueOf
    . ', ' . LookupValue('\year')->valueOf; }

#======================================================================
# Random Job related things
#----------------------------------------------------------------------
# \end              c  terminates the current job.
# \everyjob         pt holds tokens which are inserted at the start of every job.
# \deadcycles       iq is the number of times \output was called since the last \shipout.
# \maxdeadcycles    pi is the maximum allowed value of \deadcycles before an error is generated.

DefPrimitiveI('\lx@end@document', undef, sub {
  my ($stomach) = @_;
  $stomach->leaveHorizontal;
  $stomach->getGullet->flush;
  return; });
Let('\end', '\lx@end@document');

DefRegister('\everyjob'      => Tokens());
DefRegister('\deadcycles'    => Number(0));
DefRegister('\maxdeadcycles' => Number(0));

#======================================================================
# Dumping
#----------------------------------------------------------------------
# \dump             c  outputs a format file in INITEX; otherwise it is equivalent to \end.

DefMacro('\dump', sub {
    Warn('unexpected', 'dump', $_[0], "Do not know how to \\dump yet, sorry"); });

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

my @tables = (qw(value meaning
    catcode mathcode sfcode lccode uccode delcode));
my @augtables = (qw(value prelet meaning postlet
    catcode mathcode sfcode lccode uccode delcode));
my %table_installer = (value => 'V',
  catcode => 'Cc', mathcode => 'Mc', sfcode  => 'Sc',
  lccode  => 'Lc', uccode   => 'Uc', delcode => 'Dc');

my %IGNORED_SYMBOLS = map { $_ => 1; }
  qw(
  value:DOCUMENT_REWRITE_RULES
  value:PARAMETER_TYPES
  value:TAG_PROPERTIES
  value:MATH_LIGATURES
  value:TEXT_LIGATURES),
  # \lnot, \to let to \neg, \rightarrow in pre 2017 TeXlive; gratuitously screws up tests
  qw(
  meaning:\lnot
  meaning:\to
  );

#======================================================================
our $DUMP_HEADER = <<'EoCode';
#======================================================================
package LaTeXML::Internal::Dump;
use strict;
use warnings;
use LaTeXML::Package;
use LaTeXML::Core::Dumper qw(:load);
#======================================================================
EoCode

sub DumpFile {
  my ($file, $destination) = @_;
  $file = ToString($file);
  my ($dir, $name, $type) = pathname_split($file);
  $type = 'sty' unless $type;

  # What to save? Naive approach: Compare ALL symbols BEFORE loading;
  my $predump = $name . '_bootstrap';
  if (FindFile($predump, type => 'pool', installation_subdir => 'Engine')) {
    LoadPool($predump); }
  else {
    Debug("No pre-dump pool file: $predump"); }
  Debug("Pre-dump scan");
  my $snap = {};
  foreach my $table_name (@tables) {
    my $table = $$STATE{$table_name};
    foreach my $key (sort keys %$table) {
      $$snap{$table_name}{$key} = $$table{$key}[0]; } }
  Debug("pre-dump found " . join(',', map { $_ . '=' . scalar(keys %{ $$snap{$_} }); } @tables));
  # Now load the file
  Debug("Loading $file");
  if (my $path = FindFile($name, type => $type)) {
    LaTeXML::Package::loadTeXDefinitions($name, $path, type => $type); }
  else {
    Fatal('expected', $file, "Couldn't find definitions file $file"); }
  Debug("Extracting symbols " . join(',', map { $_ . '=' . scalar(keys %{ $$STATE{$_} }); } @tables));
  my $nsym  = 0;
  my $nlets = 0;
  my %unchanged=();
  my (@cmds_early, @cmds, @cmds_late);
  foreach my $table_name (sort @tables) {
    my $table = $$STATE{$table_name};
    my $inst  = $table_installer{$table_name};
    foreach my $key (sort keys %$table) {
      my $dump_key = $table_name . ':' . $key;
      my $dkey     = LaTeXML::Core::Dumper::Dump($key, $dump_key);
      next if $IGNORED_SYMBOLS{$dump_key};
      my $value    = $$table{$key}[0];
      my $dump     = LaTeXML::Core::Dumper::Dump($value, $dump_key);
      my $let_cs;
      my $prev = $$snap{$table_name}{$key};
      my $pdump     = LaTeXML::Core::Dumper::Dump($prev, $dump_key);
      if(($dump // $value // 'undef') ne ($pdump // $prev // 'undef')) {
        $nsym++;
        ## one of the simple value tables?
        if ($table_name ne 'meaning') {
          if (!(ref $value) || defined $dump) {
            push(@cmds, "$inst(" . $dkey . ',' . $dump . ")") } # Assign within table
          else {
            Warn('unexpected', $table_name, undef,
              "Do not know how to dump $table_name for $key : " . Stringify($value)); } }
        # else processing the meaning table; some kind of definition
        elsif ((!defined $value)    # Value Empty?
          || (!$value->isaDefinition)               # or menaing is non-definition; maybe a token
          || (!($let_cs = $value->getCSName))) {    # Or definition w/NO cs !?!? (can't happen?)
          push(@cmds, 'Im(' . $dkey . ',' . $dump . ')'); } # Assign meaning
        ## Else, some proper kind of definition.
        elsif ($key eq $let_cs) {                   # Normal definition
          if($dump){
            push(@cmds, 'I(' . $dump . ')'); }       # the key (the cs!) is already embedded in the dump!!!
          else {
            Warn('unexpected', $table_name, undef,
              "Do not know how to dump $table_name for $key : " . Stringify($value)); } }
        ## \let symbols? Worry about WHICH value of original cs to use? before/after?????
        else {
          $nlets++;
          my $letkey     = LaTeXML::Core::Dumper::Dump($let_cs, $dump_key);
          my $prev_let = $$snap{$table_name}{$let_cs};
          my $curr_let = $$table{$let_cs}[0];
          if ((defined $prev_let) && ($value eq $prev_let)) {
            ## \let is defn from BEFORE loading; arrange to get that value on loading.
            push(@cmds_early, 'Lt(' . $dkey . ',' . $letkey . ')'); }
          elsif ((defined $curr_let) && ($value eq $curr_let)) {
            ## \let to the current defn; do let assignment after load
            push(@cmds_late, 'Lt(' . $dkey . ',' . $letkey . ')'); }
          else {
            push(@cmds, 'Im(' . $dkey . ',' . $dump . ')'); } # Assign meaning
        } }
      else {
        $unchanged{$dump_key}++; } } }
  #----------------------------------------------------------------------
  Debug("Found $nsym new symbols; $nlets were \\let");
  Debug("There were ".scalar(keys %unchanged)." unchanged symbols");
  #. join(',', sort keys %unchanged));
  Debug("Storing $name in $destination");
  my $OUT;
  open($OUT, '>', $destination)
    or Fatal('I/O', $destination, "Failed to open format file '$destination': $!");
  binmode($OUT, ':encoding(UTF-8)');
  print $OUT ('#' x 80) . "\n";
  print $OUT "## Dump of $name\n";
  print $OUT "## Generated file, do not edit!\n";
  print $OUT $DUMP_HEADER;
  foreach my $cmd (@cmds_early) {
    print $OUT $cmd . ";\n"; }
  foreach my $cmd (@cmds) {
    print $OUT $cmd . ";\n"; }
  foreach my $cmd (@cmds_late) {
    print $OUT $cmd . ";\n"; }
  print $OUT '#' . ('=' x 80) . "\n";
  print $OUT "1;\n";
  close($OUT);
  Debug("Stored into $destination");
  return; }

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
1;
