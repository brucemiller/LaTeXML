# -*- mode: Perl -*-
# /=====================================================================\ #
# |  eTeX                                                               | #
# | enhanced TeX enhancements Implementation for LaTeXML                | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | Bruce Miller <bruce.miller@nist.gov>                        #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #
package LaTeXML::Package::Pool;
use strict;
use warnings;
use LaTeXML::Package;

# See the manual
# http://texdoc.net/texmf-dist/doc/etex/base/etex_man.pdf
# This binding has been rearranged to follow the March 2024 document

#======================================================================
# Section 3. e-TeX Extensions
#======================================================================

#======================================================================
# 3.1 Compatibility and Extended Mode

# [See Section 3.3 below]

#======================================================================
# 3.2 Optimization
# Likely nothing to do here

#======================================================================
# 3.3 Tracing and Diagnostics

# Mostly have no effect, but could.
DefRegister('\tracingassigns'    => Number(0));    # ???
DefRegister('\tracinggroups'     => Number(0));
DefRegister('\tracingifs'        => Number(0));    # ???
DefRegister('\tracingscantokens' => Number(0));
DefRegister('\tracingnesting'    => Number(0));

# Should show all open groups & their type.
DefPrimitive('\showgroups', undef);

# \showtokens <generaltext>
DefPrimitive('\showtokens GeneralText', sub {
    Note("> " . writableTokens($_[1]));
    Note($_[0]->getLocator->toString());
    return; });

#======================================================================
# 3.4 Status Enquiries

our @ETEX_VERSION = (qw(2 .6));
DefMacro('\eTeXrevision', sub { Explode($ETEX_VERSION[1]); });
DefRegister('\eTeXversion' => Number($ETEX_VERSION[0]));

DefRegister('\interactionmode' => Number(0));

# Conditional almost tracks this information, but not quite in the needed form. Punt!
# \currentiflevel
# \currentifbranch
# \currentiftype
DefRegister('\currentiflevel',  Number(0), readonly => 1);
DefRegister('\currentifbranch', Number(0), readonly => 1);
DefRegister('\currentiftype',   Number(0), readonly => 1);

# \currentgrouplevel
DefRegister('\currentgrouplevel', Number(0),
  readonly => 1,
  getter   => sub { Number($STATE->getFrameDepth); });

# \currentgrouptype returns group types from 0..16 ; but we're not tracking them yet
DefRegister('\currentgrouptype', Number(0), readonly => 1);

# ???
DefRegister('\lastnodetype', Number(0));

# \fontcharht <font><8bit>
# \fontcharwd <font><8bit>
# \fontchardp <font><8bit>
# \fontcharic <font><8bit>
DefRegister('\fontcharht FontDef Number', Dimension(0),
  readonly => 1,
  getter   => sub {
    my ($fontinfo, $code) = @_;
    my $font = $STATE->lookupValue('font')->merge(%$fontinfo);
    my ($w, $h, $d, $c) = $font->computeStringSize($code && chr($code->valueOf));
    return $h || Dimension(0); });
DefRegister('\fontcharwd FontDef Number', Dimension(0),
  readonly => 1,
  getter   => sub {
    my ($fontinfo, $code) = @_;
    my $font = $STATE->lookupValue('font')->merge(%$fontinfo);
    my ($w, $h, $d, $c) = $font->computeStringSize($code && chr($code->valueOf));
    return $w || Dimension(0); });
DefRegister('\fontchardp FontDef Number', Dimension(0),
  readonly => 1,
  getter   => sub {
    my ($fontinfo, $code) = @_;
    my $font = $STATE->lookupValue('font')->merge(%$fontinfo);
    my ($w, $h, $d, $c) = $font->computeStringSize($code && chr($code->valueOf));
    return $d || Dimension(0); });
DefRegister('\fontcharic FontDef Number', Dimension(0),
  readonly => 1,
  getter   => sub {
    my ($fontinfo, $code) = @_;
    my $font = $STATE->lookupValue('font')->merge(%$fontinfo);
    my ($w, $h, $d, $c) = $font->computeStringSize($code && chr($code->valueOf));
    return $c || Dimension(0); });    # Not actually computed here (yet)

# Assuming parshape is stored as an even list of [indentation, length, ...]
# [See TeX_Paragraph for \parshape]
# These access the indentation or length of the n-th (1-based) line, or last line.
DefRegister('\parshapeindent Number', Dimension(0),
  readonly => 1,
  getter   => sub {
    my ($n) = @_;
    $n = $n && $n->valueOf || 0; $n = 0 if $n < 0;
    my $shape = LookupValue('parshape');
    return $shape && $n && ($$shape[2 * $n - 2] || $$shape[-2]) || Dimension(0); });

DefRegister('\parshapelength Number', Number(0),
  readonly => 1,
  getter   => sub {
    my ($n) = @_;
    $n = $n && $n->valueOf || 0; $n = 0 if $n < 0;
    my $shape = LookupValue('parshape');
    return $shape && $n && ($$shape[2 * $n - 1] || $$shape[-1]) || Dimension(0); });

DefRegister('\parshapedimen Number', Dimension(0),
  readonly => 1,
  getter   => sub {
    my ($n) = @_;
    $n = $n && $n->valueOf || 0; $n = 0 if $n < 0;
    my $shape = LookupValue('parshape');
    return $shape && $n && ($$shape[$n - 1] || $$shape[(($n - 1) % 2) - 2])
      || Dimension(0); });

#======================================================================
# 3.5 Expressions

#______________________________________________________________________
# \numexpr, \dimexpr, \gluexpr, \muexpr
# These read tokens doing simple parsing until \relax or the parse fails.
# since we don't know where it ends, we can't easily use Parse::RecDescent.
# They also act like a Register!
# $type is one of Number, Dimension, Glue or MuGlue
sub etex_readexpr {
  my ($gullet, $type) = @_;
  my $value = etex_readexpr_i($gullet, $type, 0);
  if (my $token = $gullet->readToken) {    # Skip \relax
    $gullet->unread($token) unless Equals($token, T_CS('\relax')); }
  return $value; }

sub etex_readexpr_i {
  my ($gullet, $type, $prec) = @_;
  # Read a first value
  my $value;
  my $token = $gullet->readXNonSpace;
  if (!$token) {
    return; }
  elsif ($token->equals(T_OTHER('('))) {
    $value = etex_readexpr_i($gullet, $type, 0);
    my $close = $gullet->readXToken;    # close parenthesis should have terminated recursive call
    if (!$close || !$close->equals(T_OTHER(')'))) {
      Error('expected', ')', $gullet,
        "Missing close parenthesis in $type expr.", "Got " . ToString($close)); } }
  else {                                # Read core TeX value/register
    $gullet->unread($token);
    $value = $gullet->readValue($type); }

  # Now check for a following operator(s) & operand(s) (respecting precedence)
  while (my $next = $gullet->readXNonSpace) {
    if ($next->equals(T_CS('\relax'))) {
      $gullet->unread($next);    # leave the \relax for top-level to strip off.
      last; }
    elsif ($next->equals(T_OTHER('+')) && ($prec < 1)) {
      $value = $value->add(etex_readexpr_i($gullet, $type, 1)); }
    elsif ($next->equals(T_OTHER('-')) && ($prec < 1)) {
      $value = $value->subtract(etex_readexpr_i($gullet, $type, 1)); }
    elsif ($next->equals(T_OTHER('*')) && ($prec < 2)) {    # multiplier should be pure number
      $value = $value->multiply(etex_readexpr_i($gullet, 'Number', 2)); }
    elsif ($next->equals(T_OTHER('/')) && ($prec < 2)) {    # denominator should be pure number
      $value = $value->divideround(etex_readexpr_i($gullet, 'Number', 2)); }
    else {                                                  # anything else, we're done.
      $gullet->unread($next);
      last; } }
  return $value; }

DefParameterType('NumExpr',  sub { etex_readexpr($_[0], 'Number'); });
DefParameterType('DimExpr',  sub { etex_readexpr($_[0], 'Dimension'); });
DefParameterType('GlueExpr', sub { etex_readexpr($_[0], 'Glue'); });
DefParameterType('MuExpr',   sub { etex_readexpr($_[0], 'MuGlue'); });

DefRegister('\numexpr NumExpr',   Number(0),    getter => sub { $_[0]; });
DefRegister('\dimexpr DimExpr',   Dimension(0), getter => sub { $_[0]; });
DefRegister('\glueexpr GlueExpr', Glue(0),      getter => sub { $_[0]; });
DefRegister('\muexpr MuExpr',     MuGlue(0),    getter => sub { $_[0]; });

#______________________________________________________________________
# Parts of Glue
DefRegister('\gluestretchorder Glue', Number(0),
  getter => sub { $_[0]->getStretchOrder; });
DefRegister('\glueshrinkorder Glue', Number(0),
  getter => sub { $_[0]->getShrinkOrder; });
DefRegister('\gluestretch Glue', Dimension(0),
  getter => sub { $_[0]->getStretch; });
DefRegister('\glueshrink Glue', Dimension(0),
  getter => sub { $_[0]->getShrink; });

#======================================================================
# 3.6 Additional Registers and Marks

# \marks <class> <number>  [\marks0 == \mark]
# \firstmarks <Number> [\firstmarks0 == \firstmark]
DefPrimitive('\marks Number GeneralText', undef);
DefMacroI('\topmarks Number',        undef, Tokens());
DefMacroI('\firstmarks Number',      undef, Tokens());
DefMacroI('\botmarks Number',        undef, Tokens());
DefMacroI('\splitfirstmarks Number', undef, Tokens());
DefMacroI('\splitbotmarks Number',   undef, Tokens());

#======================================================================
# 3.7 Input Handling

# \readline <number> to <control sequence>
# like \read, but only spaces & other
DefMacro('\readline Number SkipKeyword:to SkipSpaces Token', sub {
    my ($gullet, $port, $token) = @_;
    $port = ToString($port);
    if (my $mouth = LookupValue('input_file:' . $port)) {
      my $line_string = ($mouth->readRawLine || '');
      # DG: Can't we do this \endlinechar check in readRawLine ?!
      # DG:  and can't we make it *faster* ?
      if (my $eol = $STATE->lookupDefinition(T_CS('\endlinechar'))) {
        my $eol   = $eol->valueOf()->valueOf;
        my $eolch = (($eol > 0) && ($eol <= 255) ? chr($eol) : undef);
        if ($eolch) {
          $line_string .= $eolch; } }
      else {
        $line_string .= "\r"; }
      DefMacroI($token, undef, Tokens(Explode($line_string)), allowUnbalanced => 1); }
    return; });

# \scantokens{...}
DefMacro('\scantokens GeneralText', sub {
    my ($gullet, $generaltext) = @_;
    $gullet->openMouth(LaTeXML::Core::Mouth->new(writableTokens($generaltext)), 0);
    return; });

# \everyeof
# NOTE: These tokens are NOT used anywhere (yet?)
DefRegister('\everyeof', Tokens());

#======================================================================
# 3.8 Breaking Paragraphs into Lines

# \lastlinefit
DefRegister('\lastlinefit', Number(0));

# Weird Array versions if \interlinepenalty, etc
# \interlinepenalties
# \clubpenalties
# \widowpenalties
# \displaywidowpenalties
# Somewhat like \parshape, they also act like perverse registers
# The getter returns the $n'th penaltie, the setter ALSO reads & stores the $n values
# Note that \interlinepenalties gets reset by \par, like \parshape.

sub eTeXPenaltiesGetter {
  my ($name) = @_;
  my $gullet = $STATE->getStomach->getGullet;
  my $n      = $gullet->readNumber;
  my $p      = LookupValue($name);
  $n = $n->valueOf; $n = 0 if $n < 0;
  return $p && $n && ($$p[$n - 1] || $$p[-1]) || Number(0); }

sub eTeXPenaltiesSetter {
  my ($name, $n) = @_;    # As if assigned to $n !!!
  $n = $n->valueOf; $n = 0 if $n < 0;
  my $gullet = $STATE->getStomach->getGullet;
  my @p      = map { $gullet->readNumber; } 1 .. $n;
  $STATE->assignValue($name => ($n ? [@p] : undef));
  return; }

DefRegister('\interlinepenalties', Number(0),
  getter => sub { eTeXPenaltiesGetter('interlinepenalties'); },
  setter => sub { eTeXPenaltiesSetter('interlinepenalties', @_); });
DefRegister('\clubpenalties', Number(0),
  getter => sub { eTeXPenaltiesGetter('clubpenalties'); },
  setter => sub { eTeXPenaltiesSetter('clubpenalties', @_); });
DefRegister('\widowpenalties', Number(0),
  getter => sub { eTeXPenaltiesGetter('widowpenalties'); },
  setter => sub { eTeXPenaltiesSetter('widowpenalties', @_); });
DefRegister('\displaywidowpenalties', Number(0),
  getter => sub { eTeXPenaltiesGetter('displaywidowpenalties'); },
  setter => sub { eTeXPenaltiesSetter('displaywidowpenalties', @_); });

#======================================================================
# 3.9 Math Formulas

DefConstructor('\middle Token', '#1',
  afterConstruct => sub {
    my ($document) = @_;
    my $current    = $document->getNode;
    my $delim      = $document->getLastChildElement($current) || $current;
    $document->setAttribute($delim, role     => 'MIDDLE');
    $document->setAttribute($delim, stretchy => 'true');
    return; });

#======================================================================
# 3.10 Hyphenation

DefRegister('\savinghyphcodes' => Number(0));
#======================================================================
# 3.11 Discarded Items

DefRegister('\savingvdiscards' => Number(0));
DefPrimitive('\pagediscards',  undef);
DefPrimitive('\splitdiscards', undef);

#======================================================================
# 3.12 Expandable Commands

# \ifdefined <token>
DefConditional('\ifdefined Token', sub { defined LookupMeaning($_[1]); });

# \ifcsname stuff \endcsname
DefConditional('\ifcsname CSName', sub { defined LookupMeaning($_[1]); });

# \iffontchar <font><8bit>

# \unless someif
DefConditional('\unless Token', sub {
    my ($gullet, $if) = @_;
    my ($defn, $test);
    if (($defn = LookupDefinition($if)) && (($$defn{conditional_type} || '') eq 'if')
      && ($test = $defn->getTest)) {
      # Invert the if's test!
      !&$test($gullet, $defn->readArguments($gullet)); }
    else {
      Error('unexpected', $if, "\\unless should not be followed by " . Stringify($if)); } });

# [See Section 3.6 for registers about marks]

# When building an expanded token list, the tokens resulting from the expansion
# of \unexpanded are not expanded further (this is the same behaviour as is
# exhibited by the tokens resulting from the expansion of
# \the〈token variable〉in both TEX and ε-TEX).
DefMacro('\unexpanded GeneralText', '#1');

# \detokenize
DefMacro('\detokenize GeneralText', sub { Explode(writableTokens($_[1])); });

# \scantokens  [see Section 3.7 above]

#======================================================================
# 4 e-TeX Enhancements
#======================================================================
# 4.1 Mixed-Direction Typesetting

# By leaving this 0, we're saying "Don't use these features"!
DefRegister('\TeXXeTstate' => Number(0));

DefMacroI('\beginL', undef, '');
DefMacroI('\beginR', undef, '');
DefMacroI('\endL',   undef, '');
DefMacroI('\endR',   undef, '');

# Should these simply ouput some unicode direction changers,
# [Things like:
#  202A;LEFT-TO-RIGHT EMBEDDING;Cf;0;LRE;;;;;N;;;;;
#  202B;RIGHT-TO-LEFT EMBEDDING;Cf;0;RLE;;;;;N;;;;;
#  202C;POP DIRECTIONAL FORMATTING;Cf;0;PDF;;;;;N;;;;;
#  202D;LEFT-TO-RIGHT OVERRIDE;Cf;0;LRO;;;;;N;;;;;
#  202E;RIGHT-TO-LEFT OVERRIDE;Cf;0;RLO;;;;;N;;;;;
# ]
# or do we need to do some more intelligent tracking of modes
# and directionality?
# Presumably we can't rely on the material itself being directional.

DefRegister('\predisplaydirection' => Number(0));    # ???

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#======================================================================
# 3.1 Additional control over expansion
# \protected associates with the next defn
# (note that it isn't actually used anywhere).
DefPrimitiveI('\protected', undef, sub {
    $STATE->setPrefix('protected'); return; }, isPrefix => 1);

#======================================================================
# X.X Orphans or Obsolete???

DefPrimitive('\pdftexcmds@directlua{}', undef);
# babel tests would fail if we had this enabled:
#DefPrimitive('\directlua{}',            undef);

# Not really sure where this comes from; pdftex?
DefRegister('\synctex', Number(0));

# Presumably obsolete...
DefMacro('\reserveinserts{}', '');

#======================================================================
1;
