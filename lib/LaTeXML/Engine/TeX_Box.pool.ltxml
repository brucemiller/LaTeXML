# -*- mode: Perl -*-
# /=====================================================================\ #
# | TeX_Box                                                             | #
# | Core TeX Implementation for LaTeXML                                 | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | Bruce Miller <bruce.miller@nist.gov>                        #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #
package LaTeXML::Package::Pool;
use strict;
use warnings;
use LaTeXML::Package;

DebuggableFeature('svg', "Debug SVG generation");
DebuggableFeature('svg_verbose', "Debug SVG generation, verbosely");
$LaTeXML::DEBUG{svg}=1 if $$LaTeXML::DEBUG{svg_verbose};

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Box Family of primitive control sequences
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#======================================================================
# These define the handler for { } (or anything of catcode BEGIN, END)

# These are actually TeX primitives, but we treat them as a Whatsit so they
# remain in the constructed tree.
#DefConstructor('{','#body', beforeDigest=>sub{$_[0]->bgroup;}, captureBody=>1);
######DefPrimitive('{', sub {
DefPrimitive(T_BEGIN, sub {
    my ($stomach) = @_;
    $stomach->bgroup;
    my $open   = Box(undef, undef, undef, T_BEGIN, isEmpty => 1, alignmentSkippable => 1);
    my $ismath = $STATE->lookupValue('IN_MATH');
    my $mode   = $STATE->lookupValue('MODE');
    my @body   = $stomach->digestNextBody();
    List($open, @body, mode => $mode); });

#######DefPrimitive('}', sub {
DefPrimitive(T_END, sub {
    my $f = LookupValue('font');
    $_[0]->egroup;
    Box(undef, $f, undef, T_END, isEmpty => 1, alignmentSkippable => 1); });

# These are for those screwy cases where you need to create a group like box,
# more than just bgroup, egroup,
# BUT you DON'T want extra {, } showing up in any untex-ing.
DefConstructor('\lx@hidden@bgroup', '#body',
  beforeDigest => sub { $_[0]->bgroup; }, captureBody => 1,
  reversion    => sub { Revert($_[0]->getProperty('body')); });
DefConstructor('\lx@hidden@egroup', '',
  afterDigest => sub { $_[0]->egroup; },
  reversion   => '');

#======================================================================
# A few useful low-level boxing things

DefConstructor('\lx@framed[]{}',
  "<ltx:text framed='#frame' _noautoclose='1'>#2</ltx:text>",
  properties => { frame => sub { ToString($_[1] || 'rectangle'); } },
  enterHorizontal => 1);

DefConstructor('\lx@hflipped{}',
  "<ltx:text class='ltx_hflipped' _noautoclose='1'>#1</ltx:text>",
  enterHorizontal => 1);

DefConstructor('\lx@overlay{}{}',
  "<ltx:text class='ltx_overlay'>"
    . "<ltx:text class='ltx_overlay_base' _noautoclose='1'>#1</ltx:text>"
    . "<ltx:text class='ltx_overlay_over' _noautoclose='1'>#2</ltx:text></ltx:text>",
  enterHorizontal => 1);

#======================================================================
DefMacro('\lx@nounicode {}', '\ifmmode\lx@math@nounicode#1\else\lx@text@nounicode#1\fi');

sub reportNoUnicode {
  my ($cs) = @_;
  $cs = ToString($cs);
  if (!LookupMapping('missing_unicode' => $cs)) {
    Warn('expected', 'unicode', $cs,
      "There's no Unicode equivalent for the symbol '$cs'");
    AssignMapping('missing_unicode' => $cs => 1); }
  return; }
# Slightly contrived so that this can be used within a DefMath
# and still declare & get the semantic properties.
DefPrimitive('\lx@math@nounicode DefToken', sub {
    my ($stomach, $cs) = @_;
    reportNoUnicode($cs);
    Box(ToString($cs), undef, undef, $cs, class => 'ltx_nounicode'); });

DefConstructor('\lx@text@nounicode DefToken',
  "<ltx:text _noautoclose='true' class='ltx_nounicode'>#1</ltx:text>",
  enterHorizontal => 1,
  afterDigest => sub {
    reportNoUnicode(ToString($_[1]->getArg(0))); });

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Box creation commands
# ----------------------------------------------------------------------
# \hbox           c  constructs a box holding horizontal material.
# \vbox           c  constructs a box holding vertical material.
# \vtop           c  is an alternate way to construct a box holding vertical material.

# \everyhbox      pt holds tokens inserted at the start of every hbox.
# \everyvbox      pt holds tokens inserted at the start of every vbox.
# ======================================================================

sub revert_spec {
  my ($whatsit, $keyword) = @_;
  my $value = $whatsit->getProperty($keyword);
  return ($value ? (Explode($keyword), Revert($value)) : ()); }

DefParameterType('BoxSpecification', sub {
    my ($gullet) = @_;
    if (my $key = $gullet->readKeyword('to', 'spread')) {
      my $keyvals = LaTeXML::Core::KeyVals->new(undef, undef, skipMissing => 1);
      $keyvals->setValue($key, $gullet->readDimension);
      $keyvals; } },
  reversion => sub {
    my ($spec) = @_;
    if (my $to = $spec && $spec->getValue('to')) {
      return Tokens(Tokenize('to'), Revert($to)); }
    elsif (my $spread = $spec && $spec->getValue('spread')) {
      return Tokens(Tokenize('spread'), Revert($spread)); }
    else {
      return; } },
  optional => 1, undigested => 1);

# Risky: I think this needs to be digested as a body to work like TeX (?)
# but parameter think's it's just parsing from gullet...
sub readBoxContents {
  no warnings 'recursion';
  my ($gullet, $everybox, $mode) = @_;
  my $stomach = $STATE->getStomach;
  my $t;
  while (($t = $gullet->readToken) && !$t->defined_as(T_BEGIN)) { }    # Skip till { or \bgroup
  # Now, insert some extra tokens, if any, possibly from \afterassignment
  if (my $token = LookupValue('BeforeNextBox')) {
    AssignValue(BeforeNextBox => undef, 'global');
    $gullet->unread($token); }
  # AND, insert any extra tokens passed in, due to everyhbox or everyvbox
  $gullet->unread($everybox->unlist) if $everybox;
  $stomach->beginMode($mode);   # and new group!
  my $token;
  # Like $stomach->invokeToken(T_BEGIN), but building List in correct mode
  local @LaTeXML::LIST = ();
  while (defined($t = $gullet->getPendingComment || $gullet->readXToken(1))) {
    last if $t->defined_as(T_END);
    push(@LaTeXML::LIST, $stomach->invokeToken($t)); }
  $stomach->endMode($mode);     # end mode, and close extra group
  return List(@LaTeXML::LIST, mode=>$mode); }

DefRegister('\everyhbox', Tokens());
DefRegister('\everyvbox', Tokens());

DefParameterType('HBoxContents', sub {
    readBoxContents($_[0], LookupValue('\everyhbox'), 'restricted_horizontal'); },
  undigested => 1,    # Cause it already is digested!
  reversion => sub { (T_BEGIN, Revert($_[0]), T_END); });

DefParameterType('VBoxContents', sub {
    readBoxContents($_[0], LookupValue('\everyvbox'), 'internal_vertical'); },
  undigested => 1,    # Cause it already is digested!
  reversion => sub { (T_BEGIN, Revert($_[0]), T_END); });


# Obsolete/Deprecated
sub reenterTextMode {
  my ($verticalmode) = @_;
  return }

# Similarly, for metadata appearing within peculiar environments, fonts, etc
# You'll typically want this within a group or bounded=>1.
sub neutralizeFont {
  AssignValue(font     => LaTeXML::Common::Font->textDefault(), 'local');
  AssignValue(mathfont => LaTeXML::Common::Font->mathDefault(), 'local');
  return; }

sub REF {
  my ($thing, $key) = @_;
  return $thing && $$thing{$key}; }

sub inSVG {
  my $document = $LaTeXML::DOCUMENT;
  my $context  = $document->getElement;
  return $context && $document->getNodeQName($context) =~ /^svg:/; }

# Collapse redundant svg:g nodes that have only certain
# non-cummulative attributes
Tag('svg:g', afterClose => \&collapseSVGGroup);
my %collapsible_group_attributes = map { ($_ => 1); }
  qw(fill fill-rule fill-opacity
  stroke stroke-width stroke-linecap stroke-linejoin stroke-miterlimit
  stroke-dasharray stroke-dashoffset stroke-opacity
  color);

# Collapse/remove/unwrap unneeded svg:g's to reduce depth of tree
sub collapseSVGGroup {
  my ($document, $node) = @_;
  my ($nempty, $nredundant, $nmerged, $npopped, $npushed) = (0, 0, 0, 0, 0);
  # Record the attributes on $node, for later use.
  my %nodeattr = ();
  foreach my $attr ($node->attributes) {
    my $key = $attr->getName;
    $nodeattr{$key} = $attr->getValue if ($key !~ /^_/); }
  return if defined $nodeattr{'clip-path'};    # Needs separate svg:g node (?)
  my @children = element_nodes($node);
  # Remove empty svg:g children
  foreach my $c (@children) {
    if (($document->getNodeQName($c) eq 'svg:g') && !scalar(element_nodes($c))) {
      $nempty++;
      $document->removeNode($c); } }
  @children = element_nodes($node) if $nempty;
  # Move ahead, all leading children whose svg:g attributes completely mask $node's attributes.
  # Could do same moving trailing children to back
  my $c;
  while (scalar(@children) && ($document->getNodeQName($c = $children[0]) eq 'svg:g')) {
    my $nmasked = 0;
    foreach my $attr ($c->attributes) {
      my $key = $attr->getName;
      if (($key !~ /^_/) && $collapsible_group_attributes{$key} && defined $nodeattr{$key}) {
        $nmasked++; } }
    last unless $nmasked == scalar(keys %nodeattr);              # child completely masks attr of node
    $node->parentNode->insertBefore(shift(@children), $node);    # move it outside!
    $npopped++; }
  # Same story for trailing children, but move behind
  while (scalar(@children) && ($document->getNodeQName($c = $children[-1]) eq 'svg:g')) {
    my $nmasked = 0;
    foreach my $attr ($c->attributes) {
      my $key = $attr->getName;
      if (($key !~ /^_/) && $collapsible_group_attributes{$key} && defined $nodeattr{$key}) {
        $nmasked++; } }
    last unless $nmasked == scalar(keys %nodeattr);              # child completely masks attr of node
    $node->parentNode->insertAfter(pop(@children), $node);
    $npushed++; }
  # Now remove any redundant svg:g's (same attributes & values) [some left after above]
  foreach my $c (@children) {
    if ($c && ($document->getNodeQName($c) eq 'svg:g')) {        # for every nested svg:g
      my $issame = 1;
      foreach my $attr ($c->attributes) {
        my $key = $attr->getName;
###        if (($key !~ /^_/) && ($attr->getValue ne ($nodeattr{$key} || ''))) {
        if (($key !~ /^_/)
          && (($attr->getValue ne ($nodeattr{$key} || '')) || ($key eq 'transform'))) {
          $issame = 0; } }
      if ($issame) {    # child is completely redundant.
        $document->unwrapNodes($c);
        $nredundant++; } } }
  @children = element_nodes($node) if $nredundant;
  # Could check if $node is empty now?
  # Then if only one left, and it's attributes can be migrated to $node, unwrap it
  if ((scalar(@children) == 1) && ($document->getNodeQName($c = $children[0]) eq 'svg:g')) {
    my %av        = ();
    my $mergeable = 1;
    foreach my $attr ($c->attributes) {
      my $key = $attr->getName;
      if (($key =~ /^_/) || $collapsible_group_attributes{$key}) {
        $av{$key} = $attr->getValue; }
      elsif ($key eq 'transform') {
        $av{$key} = ($nodeattr{$key} ? $nodeattr{$key} . ' ' : '') . $attr->getValue; }
      else {
        $mergeable = 0; } }
    if ($mergeable) {
      foreach my $key (sort keys %av) {
        $nodeattr{$key} = $av{$key};
        $node->setAttribute($key => $av{$key}); }
      $nmerged++;
      $document->unwrapNodes($c); } }
  return; }

# Add a box showing where something "should" be, for debugging purposes
# Typically will be within an svg:g which establishes position & scale.
# in which case (see below), it will be moved to be the last child so it overlays
sub addSVGDebuggingBox {
  my($document,$x,$y,$w,$h,$color)=@_;
  ($x, $y, $w, $h) = map { (ref $_ ? $_->pxValue : $_); } ($x, $y, $w, $h);
  my $x1 = $x + $w;
  my $y1 = $y + $h;
  $color = $color || '#FF0000';
  $document->openElement('svg:g',
    _svg_debug_box => 1, stroke => $color, 'stroke-width' => 0.4, fill => 'none');
  $document->insertElement('svg:rect', undef,
    x => $x, y => $y, width => $w, height => $h);
  $document->insertElement('svg:path', undef, d => "M $x 0 L $x1 0") if $x;
  $document->insertElement('svg:path', undef, d => "M 0 $y L 0 $y1") if $y;
  $document->closeElement('svg:g');
  return; }

# Move any debugging boxes to the end of their svg:g, so they overlay the content
Tag('svg:g', afterClose => sub {
  my ($document, $node) = @_;
  my ($first,@more) = element_nodes($node);
  if($first && $first->getAttribute('_svg_debug_box') && @more) {
    $node->removeChild($first);
    $node->appendChild($first); }
  return; });

DefConstructor('\hbox BoxSpecification HBoxContents', sub {
    # "<ltx:text width='#width' _noautoclose='1'>#2</ltx:text>",
    no warnings 'recursion';
    my ($document, $spec, $contents, %props) = @_;
    my $model   = $document->getModel;
    my $current = $document->getElement;
    my $tag     = $current && $document->getNodeQName($current);
    # What is the CORRECT (& general) way to ask whether we're in "vertical mode"??
    #  my $vmode = $tag eq 'ltx:inline-block'; # ie, explicitly \vbox !?!?!?!
    my $issvg  = $current && $tag =~ /^svg:/;
    my $vmode  = $current && ($tag eq 'ltx:_CaptureBlock_'); # if going into insertBlock
    my $inline = $document->canContain($current, '#PCDATA');
    my $newtag = ($issvg ? 'svg:g' : ($vmode ? ($inline ? 'ltx:inline-block' : 'ltx:p') : 'ltx:text'));
    my $node   = $document->openElement($newtag, _noautoclose => 1, width => $props{width});
    $document->absorb($contents);
    if($issvg && $LaTeXML::DEBUG{svg} && $document->findnodes('svg:foreignObject',$node)){
      my ($w, $h, $d) = map { $_->pxValue; } $_[2]->getSize;
      addSVGDebuggingBox($document,0,-$d,$w,$h+$d,'#00FFFF'); }
    if (!$issvg) {              # If not directly svg, but nested within closeable (???)
      while (!$document->getElement()->hasAttribute('_beginscope') && $document->maybeCloseElement('svg:g')) { }
      $document->maybeCloseElement('svg:svg'); }
    $document->maybeCloseNode($node);
  },
  mode  => 'restricted_horizontal',
  sizer => '#2',
  afterDigest => sub {
    my ($stomach, $whatsit) = @_;
    my $spec = $whatsit->getArg(1);
    my $box  = $whatsit->getArg(2);
    if (my $w = GetKeyVal($spec, 'to')) {
      $whatsit->setWidth($w); }
    elsif (my $s = GetKeyVal($spec, 'spread')) {
      $whatsit->setWidth($box->getWidth->add($s)); }
    $whatsit->setProperty(content_box => $box);
    return; });

# Cleanup foreignObjects: remove empty (or only <p/>); and determine size
Tag('svg:foreignObject', autoOpen => 1, autoClose => 1,
  afterClose => sub {
    my ($document, $node, $whatsit) = @_;
    ## NOTE: The revised schema now allows plain text within foreignObject; watch out for mixed
    my @fo = $node->childNodes;    # What's in the foreignObject?
    if (scalar(@fo) == 0) {        # Empty?
      $document->removeNode($node);    #  just remove whole thing
      return; }
    elsif (!grep { $_->nodeType != XML_TEXT_NODE } @fo) {    # All text nodes?
      $node = $document->renameNode($node, 'svg:text');
      $node->setAttribute(transform => "matrix(1 0 0 -1 0 0)");
      return; }
    elsif ((scalar(@fo) == 1) && ($document->getNodeQName($fo[0]) eq 'ltx:p')) {    # Single <p/>?
      my @p_c = element_nodes($fo[0]);
      if (scalar(@p_c) == 0) {                                                      # or Empty <p/>?
        $document->removeNode($node);
        return; }
      # Else, single ltx:picture or ltx:text ?
      elsif (scalar(@p_c) == 1) {
        my $tag = $document->getNodeQName($p_c[0]);
        if (($tag eq 'ltx:picture') || ($tag eq 'ltx:text')) {
          my @pic_c = element_nodes($p_c[0]);
          # With single svg:svg ?
          if ((scalar(@pic_c) == 1) && ($document->getNodeQName($pic_c[0]) eq 'svg:svg')) {
            $document->replaceNode($node, element_nodes($pic_c[0]));
            return; } } } }
    # Otherwise, we've still got an svg:foreignObject;
    # Make sure we get a size, in case autoOpen'd
    # Reminder: TeX/LaTeXML think origin is left & baseline
    # svg foreignObject content will draw down from the top
    if ($whatsit) {
      my ($w, $h, $d) = $whatsit->getSize;
      my $H = $h->add($d);
      my $W = $w;
      my $x = Dimension(0);
      my $y = $h;
      my $f = $whatsit->getFont;
      Debug("SVG:foreignObject ".$w->pxValue.' x '.$h->pxValue.' x '.$d->pxValue."; "
        . " => H=".$H->pxValue." @ y=".$y->pxValue
        . " for Whatsit=".ToString($whatsit)) if $LaTeXML::DEBUG{svg_verbose};
      # Size of FO is width and total height (+ depth)
      $node->setAttribute(width     => $W->pxValue) unless $node->hasAttribute('width');
      $node->setAttribute(height    => $H->pxValue) unless $node->hasAttribute('height');
      # Set top of FO height above current, as if baseline will line up w/outside
      $node->setAttribute(transform => 'matrix(1 0 0 -1 '.$x->pxValue.' '.$y->pxValue.')');
      $node->setAttribute(overflow  => 'visible');
      # Store expected size for experimentation Temporary?
      $document->setAttribute($node,
        style=>'--ltx-fo-width:'  . $w->emValue(undef,$f).'em;'
              .'--ltx-fo-height:' . $h->emValue(undef,$f).'em;'
              .'--ltx-fo-depth:'  . $d->emValue(undef,$f).'em;');
 } });

sub isVAttached {
  my ($node) = @_;
  while($node) {
    return 1 if $node->hasAttribute('vattach');
    my (@children) = $node->childNodes;
    return if (scalar(@children) != 1) || ($children[0]->nodeType != XML_ELEMENT_NODE);
    $node = $children[0]; }
  return; }

# This attempts to be a generalize vbox construction;
# The idea is to receeive block-like material, possibly wrapped in appropriate
# container which gets attributes.
# The contents are constructed in an ltx:_CaptureBlock_ element,
# designed to accept all reasonable block material from several levels,
# and then determine which container element is most apprpriate for both the conent & context
# from block, logical-block or sectional-block, or the inline- variants.
sub insertBlock {
  my ($document, $contents, %blockattr) = @_;
  my $model   = $document->getModel;
  my $context = $document->getElement;    # Where we originally start inserting.
  if (!$context) {
    # edge case: if we start the doc with a block, the context is empty
    $document->absorb($contents);
    return; }
  my $context_tag    = $document->getNodeQName($context);
  my $is_svg         = ($context_tag =~ /^svg:/);              # svg is slightly tricky
  my $ignorable_attr = $is_svg || !scalar(keys %blockattr);    # if we do not REQUIRE the attributes
  if (($context_tag =~ /^ltx:XM/) && ($context_tag ne 'ltx:XMText')) {    # but math always needs this
    $context     = $document->openElement('ltx:XMText');
    $context_tag = $document->getNodeQName($context); }
  if(my $w = $is_svg && $blockattr{width}) {
    $blockattr{width} = $w->emValue(undef, $contents->getFont) . "em" if ref $w; }
  my $inline    = $is_svg || $document->canContain($context_tag, '#PCDATA');
  my $container = $document->openElement('ltx:_CaptureBlock_', %blockattr);
  $document->absorb($contents);
  my @nodes     = content_nodes($container);
  my @node_tags = map { $document->getNodeQName($_); } @nodes;
  my $nnodes    = scalar(@nodes);
  $document->closeToNode($container, 1);
  $document->closeNode($container);
  $document->closeToNode($context, 1);
  # Hack: apparently TeX doesn't shift (vattach) a single node in a vbox/vtop/...
  if(($nnodes == 1) && exists($blockattr{vattach}) && isVAttached($nodes[0])) {
    $container->removeAttribute('vattach');
    delete $blockattr{vattach}; 
    $ignorable_attr = $is_svg || !scalar(keys %blockattr); }
  my $newcontainer;
  if ($nnodes < 1) {    # Insertion came up empty?
    $document->removeNode($container); }    # then remove the new block entirely
  elsif ($ignorable_attr                    # No attributes, contents allowed in context?
    && !grep { !$document->canContain($context, $_); } @node_tags) {
    $document->unwrapNodes($container); }    # No container needed, at all.
  elsif (($nnodes == 1)                      # Single node, allowed in context & accepts attributes
    && $document->canContain($context, $nodes[0])
    && ($ignorable_attr || !grep { !$document->canHaveAttribute($nodes[0], $_) } keys %blockattr)) {
    map { $document->setAttribute($nodes[0], $_ => $blockattr{$_}) } keys %blockattr;
    $document->unwrapNodes($container); }    # Add attributes and unwrap the single node
  elsif (($nnodes == 1)    # Single node, but needs auto-wrapper which accepts attributes?
    && ($newcontainer = $document->canContainSomehow($context, $nodes[0]))
    && ($ignorable_attr || !grep { !$document->canHaveAttribute($newcontainer, $_) } keys %blockattr)) {
    $document->renameNode($container, $newcontainer, 1); }    # rename the capture to that container
  else {                                                      # Otherwise, rename the capture
    if ($is_svg && grep { $_ =~ /^ltx:/; } @node_tags) {      # MAY need foreignObject wrapper
      $context     = $document->wrapNodes('svg:foreignObject', $container);
      $context_tag = $document->getNodeQName($context); }
    my @candidates =
      ($inline
      ? (qw(ltx:inline-block ltx:inline-logical-block ltx:inline-sectional-block))
      : (qw(ltx:block ltx:logical-block ltx:sectional-block ltx:figure)));
    my @filtered_candidates = ();    # Filtered containers that can contain the content
    foreach my $candidate (@candidates) {
      push(@filtered_candidates, $candidate)
        unless grep { !$document->canContainSomehow($candidate, $_); } @node_tags; }
    my @allowed_candidates           # and are allowed in the context
      = grep { ($document->canContain($context_tag, $_) ? $_ : ()); } @filtered_candidates;
    if (my $tag = $allowed_candidates[0] || $filtered_candidates[0]) {
      $document->renameNode($container, $tag, 1); }    # Rename the capture to the correct container
    else {                                             # we didn't know what to do?
      Warn('malformed', '_CaptureBlock_', $document, "Did not find a block-like candidate in $context_tag (with attributes (" . join(";", map { "$_=$blockattr{$_}" } keys %blockattr) . ')');
      $document->renameNode($container, 'ltx:block', 1);
    }
  }
  return @nodes; }

# Make sure the vbox/vtop attachment propogates to arg, when \halign or paragraph.
sub hackVBoxAttachment {
  my ($box, $valign) = @_;
  # APPARENTLY \halign in TeX is processed into a internal_vertical list
  # which can get the valign adjustment. So we need to copy it over to the Alignment
  # But this does NOT affect {tabular} environments!
  if(my $alignment = $box && $box->getProperty('alignment')){
    my $def = $box->getDefinition;
    if($def && ($def->getCSName eq '\halign')){
      if(my $attr = $alignment->getProperty('attributes')){
        $$attr{vattach} = $valign; } } }
  else {
    $box->setProperty(vattach => $valign); }
  return; }

DefConstructor('\vbox BoxSpecification VBoxContents', sub {
    my ($document, $spec, $contents, %props) = @_;
    # is_vbox property detects nested \vbox|\vtop : only inner one affects vattach!
    my @block = ($contents->getProperty('is_vbox')
                 ? $document->absorb($contents)
                 : insertBlock($document, $contents, vattach => 'bottom')); },
  sizer       => '#2',
  properties  => { vattach => 'bottom' },
  mode        => 'internal_vertical',
  afterDigest => sub {
    my ($stomach, $whatsit) = @_;
    my $spec = $whatsit->getArg(1);
    my $box  = $whatsit->getArg(2);
    hackVBoxAttachment($box, 'bottom');
    if (my $h = GetKeyVal($spec, 'to')) {
      $whatsit->setHeight($h); }
    elsif (my $s = GetKeyVal($spec, 'spread')) {
      $whatsit->setHeight($box->getHeight->add($s)); }
    $whatsit->setProperty(content_box => $box);
    $whatsit->setProperty(is_vbox => 1);
    return; });

DefConstructor('\vtop BoxSpecification VBoxContents', sub {
    my ($document, $spec, $contents, %props) = @_;
    # is_vbox property detects nested \vbox|\vtop : only inner one affects vattach!
    my @block = ($contents->getProperty('is_vbox')
                 ? $document->absorb($contents)
                 : insertBlock($document, $contents, vattach => 'top')); },
  sizer       => '#2',
  properties  => { vattach => 'top' },
  mode        => 'internal_vertical',
  afterDigest => sub {
    my ($stomach, $whatsit) = @_;
    my $spec = $whatsit->getArg(1);
    my $box  = $whatsit->getArg(2);
    hackVBoxAttachment($box, 'top');
    if (my $h = GetKeyVal($spec, 'to')) {
      $whatsit->setHeight($h); }
    elsif (my $s = GetKeyVal($spec, 'spread')) {
      $whatsit->setHeight($box->getHeight->add($s)); }
    $whatsit->setProperty(content_box => $box);
    $whatsit->setProperty(is_vbox => 1);
    return; });

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Commands to store and use boxes
# ----------------------------------------------------------------------
# \setbox         c  assigns an hbox, vbox, or vtop to a box register.
# \dp             iq is the depth of a box.
# \ht             iq is the height of a box.
# \wd             iq is the width of a box.
# \box            c  puts the box's contents in the current list and empties the box.
# \copy           c  puts the box's contents in the current list but does not empty the box     .
# \unhbox         c  puts unwrapped hbox contents in the current list and empties the box.
# \unhcopy        c  puts unwrapped hbox contents in the current list but does not empty the box.
# \unvbox         c  puts unwrapped vbox contents in the current list and empties the box.
# \unvcopy        c  puts unwrapped vbox contents in the current list but does not empty the box.
# \lastbox        c  is void or the last hbox or vbox on the current list.
# ======================================================================

DefPrimitive('\lastbox', sub {    # Hopefully, the correct box got seen!
    return pop(@LaTeXML::LIST); });

DefPrimitive('\setbox Number SkipSpaces SkipMatch:=', sub {
    my ($stomach) = @_;
    no warnings 'recursion';
    my $box = 'box' . $_[1]->valueOf;
    # If there is any afterAssignment tokens, move them over so BoxContents parameter will use them
    if (my $token = LookupValue('afterAssignment')) {
      AssignValue('afterAssignment' => undef, 'global');
      AssignValue('BeforeNextBox'   => $token); }
    # Save global flag, since we're digesting to get the box content, which resets the flag!
    # Should afterDigest be responsible for resetting flags?
    my $scope = $STATE->getPrefix('global') && 'global';
    $STATE->clearPrefixes;    # before invoke, below; we've saved the only relevant one (global)
    # Digest box starting from Default color, background; TeX Boxes don't record these.
    my $font = $STATE->lookupValue('font');
    $STATE->assignValue(font => $font->merge(color => Black, background => undef));
    my ($stuff, @rest) = $stomach->invokeToken($stomach->getGullet->readXToken);
    AssignValue('box' . $_[1]->valueOf => $stuff, $scope);
    $STATE->assignValue(font => $font);
    @rest; });

# <box dimension> = \ht | \wd | \dp
DefRegister('\ht Number', Dimension(0),
  getter => sub {
    my ($n) = @_;
    my $stuff = $n && LookupValue('box' . $n->valueOf);
    return ($stuff ? $stuff->getHeight : Dimension(0)); },
  setter => sub {
    my ($value, $scope, $n) = @_;
    my $stuff = $n && LookupValue('box' . $n->valueOf);
    $stuff->setHeight($value) if $stuff;
    return; });
DefRegister('\wd Number', Dimension(0),
  getter => sub {
    my ($n) = @_;
    my $stuff = $n && LookupValue('box' . $n->valueOf);
    return ($stuff ? $stuff->getWidth : Dimension(0)); },
  setter => sub {
    my ($value, $scope, $n) = @_;
    my $stuff = $n && LookupValue('box' . $n->valueOf);
    $stuff->setWidth($value) if $stuff;
    return; });

DefRegister('\dp Number', Dimension(0),
  getter => sub {
    my ($n) = @_;
    my $stuff = $n && LookupValue('box' . $n->valueOf);
    return ($stuff ? $stuff->getDepth : Dimension(0)); },
  setter => sub {
    my ($value, $scope, $n) = @_;
    my $stuff = $n && LookupValue('box' . $n->valueOf);
    $stuff->setDepth($value) if $stuff;
    return; });

# Adjust the default color of $box to be the current color,
# creating a copy of the box if needed.
sub adjustBoxColor {
  my ($box) = @_;
  my $font = LookupValue('font');
  my $color = $font && $font->getColor;
  my $bgcolor = $font && $font->getBackground;
  if(($color && !Black->equals($color)) || ($bgcolor && !White->equals($bgcolor))){
    return _color_adjust($color, $bgcolor, {}, $box); }
  return $box; }

# This internal function essentially clones all digested objects (Box, List, Whatsit,...)
# while adjusting any contained Font objects as it goes. If a font uses a default clor
# or background, it will be changed to the requested colors.
sub _color_adjust {
  no warnings 'recursion';
  my ($fg, $bg, $cache, $object) = @_;
  return $object unless $object;
  return $$cache{$object} if $$cache{$object};    # Nested, possibly circular, structures
  my $type = ref $object;
  my $adj = $object;
  if($type eq 'ARRAY'){
    $adj = [map { _color_adjust($fg, $bg, $cache, $_); } @$object]; }
  elsif($type eq 'HASH'){
    $adj = {map { $_=>_color_adjust($fg, $bg, $cache, $$object{$_}); } keys %$object}; }
  # NASTY access to internal structure; but worth a whole API for this one hack???
  elsif ($type =~ /^LaTeXML::Core::(?:Box|List|Whatsit|Alignment)$/) { # blessed hashes!
    $$cache{$object} = $adj = bless {%$object}, $type; # Cache BEFORE recursion!
    map { $$adj{$_} = _color_adjust($fg, $bg, $cache, $$object{$_}); } keys %$object; }
  elsif($type eq 'LaTeXML::Common::Font'){
    # Replace "default" color & background color by the requested $fg,$bg.
    # We'll use eq (of refs) hoping that detects inherited defaults,
    # rather than explicitly assigned black or white colors.
    $adj = $object;
    $adj = $adj->merge(color => $fg)      if Black eq ($object->getColor || Black);
    $adj = $adj->merge(background => $bg) if White eq ($object->getBackground || White); }
  $$cache{$object} = $adj;
  return $adj; }

DefPrimitive('\box Number', sub {
  my ($stomach, $n) = @_;
  my $box   = 'box' . $n->valueOf;
  my $stuff = adjustBoxColor(LookupValue($box));
  AssignValue($box, undef, 'inplace');
  return ($stuff ? $stuff : ()); });

DefPrimitive('\copy Number', sub {
  my ($stomach, $n) = @_;
  my $box   = 'box' . $n->valueOf;
  my $stuff = adjustBoxColor(LookupValue($box));
  return ($stuff ? $stuff : ()); });

# \unhbox<8bit>, \unhcopy<8bit>
DefPrimitive('\unhbox Number', sub {
  my ($stomach, $n) = @_;
  my $box   = 'box' . $n->valueOf;
  my $stuff = adjustBoxColor(LookupValue($box));
  my $m     = ($stuff && $stuff->getProperty('mode')) || '';
  $stomach->enterHorizontal;
  AssignValue($box, undef, 'inplace');
  # Only unlist if box is horizontal
  return (!defined $stuff ? () : ($m =~ /horizontal$/ ? $stuff->unlist : $stuff)); });

DefPrimitive('\unhcopy Number', sub {
  my ($stomach, $n) = @_;
  my $box   = 'box' . $n->valueOf;
  my $stuff = adjustBoxColor(LookupValue($box));
  my $m     = ($stuff && $stuff->getProperty('mode')) || '';
  $stomach->enterHorizontal;
  # Only unlist if box is horizontal
  return (!defined $stuff ? () : ($m =~ /horizontal$/ ? $stuff->unlist : $stuff)); });

# \unvbox<8bit>, \unvcopy<8bit>
DefPrimitive('\unvbox Number', sub {
  my ($stomach, $n) = @_;
  my $box   = 'box' . $n->valueOf;
  my $stuff = adjustBoxColor(LookupValue($box));
  my $m     = ($stuff && $stuff->getProperty('mode')) || '';
  $stomach->leaveHorizontal;
  AssignValue($box, undef, 'inplace');
  # Only unlist if box is vertical
  return (!defined $stuff ? () : ($m =~ /vertical$/ ? $stuff->unlist : $stuff)); });

DefPrimitive('\unvcopy Number', sub {
  my ($stomach, $n) = @_;
  my $box   = 'box' . $n->valueOf;
  my $stuff = adjustBoxColor(LookupValue($box));
  my $m     = ($stuff && $stuff->getProperty('mode')) || '';
  $stomach->leaveHorizontal;
  # Only unlist if box is vertical
  return (!defined $stuff ? () : ($m =~ /vertical$/ ? $stuff->unlist : $stuff)); });

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Various box related parameters
# ----------------------------------------------------------------------
# \prevdepth      iq is the depth of the last box added to the current vertical list.
# \boxmaxdepth    pd is the maximum possible depth of a vertical box.
# \badness        iq is 0-10,000 and represents the badness of the glue settings in the last constructed box.
# \hbadness       pi is the badness above which bad hboxes are reported.
# \vbadness       pi is the badness above which bad vboxes are reported.
# \hfuzz          pd is the overrun allowed before overfull hboxes are reported.
# \vfuzz          pd is the overrun allowed before overfull vboxes are reported.
# \overfullrule   pd is the width of the rule appended to an overfull box.
# ======================================================================

DefRegister('\prevdepth'   => Dimension(0));
DefRegister('\boxmaxdepth' => Dimension('16383.99999pt'));

DefRegister('\hfuzz'        => Dimension('0.1pt'));
DefRegister('\vfuzz'        => Dimension('0.1pt'));
DefRegister('\overfullrule' => Dimension('5pt'));

DefRegister('\badness'  => Number(0), readonly => 1);
DefRegister('\hbadness' => Number(1000));
DefRegister('\vbadness' => Number(1000));

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Rules and Leaders
# ----------------------------------------------------------------------
# \hrule          c  makes a rule box in vertical mode.
# \vrule          c  makes a rule box in horizontal mode.
# \cleaders       c  insert centered leaders.
# \leaders        c  fill space using specified glue with a box or rule.
# \xleaders       c  insert expanded leaders.
# ======================================================================

DefParameterType('RuleSpecification', sub {
    my ($gullet) = @_;
    my $keyvals = LaTeXML::Core::KeyVals->new(undef, undef, skipMissing => 1);
    while (my $key = $gullet->readKeyword('width', 'height', 'depth')) {
      $keyvals->setValue($key, $gullet->readDimension); }
    $keyvals; },
  optional => 1, undigested => 1);

# \hrule, \vrule are awkward in trying to deal with 3 cases
#  * as rules within an alignment/table
#  * as separating lines within text
#  * as graphical lines within svg
# and each has different requirements for size
DefConstructor('\vrule RuleSpecification',
  "?#invisible()(?#isVerticalRule()"
    . "(?&inSVG()(<svg:path d='M 0 0 L 0 #sheight'/>)"
    . "(<ltx:rule height='#rheight' depth='#rdepth' width='#rwidth' color='#color'/>)))",
  afterConstruct => sub {    # NOTE: Only For xy development!
    Warn('unexpected', 'vrule', $_[0], "Encountered \\vrule in SVG") if inSVG(); },
  afterDigest => sub {
    my ($stomach, $whatsit) = @_;
    my $dims   = $whatsit->getArg(1);
    my $width  = GetKeyVal($dims, 'width');    # || Dimension('0.4pt');
    my $height = GetKeyVal($dims, 'height');
    my $depth  = GetKeyVal($dims, 'depth');
    $stomach->enterHorizontal;
    $whatsit->setProperties(
      rwidth  => $width,  cwidth  => $width || Dimension('0.4pt'),
      rheight => $height, cheight => ($height), sheight => ($height ? $height->pxValue : 0),
      rdepth  => $depth,  cdepth  => ($depth || Dimension(0)));
    my $w = ($width  ? $width->ptValue  : undef);
    my $h = ($height ? $height->ptValue : undef);
    my $d = ($depth  ? $depth->ptValue  : undef);
    if (my $alignment = LookupValue('Alignment')) {
      if (((!defined $h) && (!defined $w)) || ((defined $h) && ($h > 20))
        || ((defined $h) && (defined $w) && ($h > 3 * $w))) {
        $whatsit->setProperty(isVerticalRule => 1) } }    # Marked as rule within alignment
    elsif ((defined $w) && ($w == 0)) {
      $whatsit->setProperty(invisible => 1); }
    if (my $color = LookupValue('font')->getColor) {
      if (!Black->equals($color)) {
        $whatsit->setProperty(color => $color); } }
    return; });

DefConstructor('\hrule RuleSpecification',
  "?#isHorizontalRule()"
    . "(?&inSVG()(<svg:path d='M 0 0 L #swidth 0'/>)"
    . "(<ltx:rule height='#rheight' depth='#rdepth' width='#rwidth' color='#color'/>))",
  afterConstruct => sub {    # NOTE: Only For xy development!
    Warn('unexpected', 'hrule', $_[0], "Encountered \\hrule in SVG") if inSVG(); },
  beforeConstruct => sub {
    my ($document, $whatsit) = @_;
    my $w = $whatsit->getProperty('rwidth');
    $_[0]->maybeCloseElement('ltx:p') if $w && ($w eq '100%'); },
  afterDigest => sub {
    my ($stomach, $whatsit) = @_;
    my $dims   = $whatsit->getArg(1);
    my $width  = GetKeyVal($dims, 'width');
    my $height = GetKeyVal($dims, 'height');
    my $depth  = GetKeyVal($dims, 'depth');
    $stomach->leaveHorizontal;
    $whatsit->setProperties(
      rwidth  => $width  || '100%', cwidth  => $width, swidth => ($width ? $width->pxValue : 0),
      rheight => $height || '1px',  cheight => ($height || Dimension('0.4pt')),
      rdepth  => $depth, cdepth => ($depth || Dimension(0)));
    my $w = ($width  ? $width->ptValue  : undef);
    my $h = ($height ? $height->ptValue : undef);
    my $d = ($depth  ? $depth->ptValue  : undef);
    if (my $alignment = LookupValue('Alignment')) {
      # What is the intended logic here?
      if (((!defined $h) && (!defined $w)) || ((defined $w) && ($w > 20))
        || ((defined $h) && (defined $w) && ($w > 3 * $h))) {
        $alignment->addLine('t');
        $whatsit->setProperty(isHorizontalRule => 1) } }    # Marked as rule within alignment
    if (my $color = LookupValue('font')->getColor) {
      if (!Black->equals($color)) {
        $whatsit->setProperty(color => $color); } }
    return; });

# ======================================================================
# Various leaders, mostly faking it for now...

# \leaders <box or rule><glue>  fills the space specified by <glue> (which may be \hfill)
#  with copies of the <box or glue>
# \cleaders similarly, but centers the result, if it doesn't completely fill <glue>
# \xleaders similarly, but stretches the result, if it doesn't completely fill <glue>
# Note that the <glue> is NOT a Glue (eg a glue specification), but something like \hfill

# Normally, these are used in a TOC, with a variable width (reflow),
# so you'd hope for some adaptive CSS approach.
# But the CSS is tricky, and you need CSS to control the leader's container as well.
# However, occasionally, leaders appear within an object with an explicitly requested width,
# so maybe it's reasonable to set the width (or duplicate the filler) to fill that width?
# Alternatively, you may wish to simply hide ltx_leaders
DefConstructor('\leaders Digested Digested', sub {
    my ($document, $filler, $glue) = @_;
    my $fw = $filler->getWidth;
    #    my $context = $document->getNode;
    my $context = $document->getElement;
    Debug("LEADERS of " . Stringify($filler) . " to fill " . Stringify($glue));
    my $cbox      = $document->getNodeBox($context);
    my $container = $document->openElement('ltx:text', _noautoclose => 1);
    my ($fnode)   = $document->absorb($filler);
    my ($unwrap, $fillw, $reqw);
    # EXPLICITLY requested width?
    if ($fnode && $cbox && ($reqw = $cbox->getProperty('width'))) {
      if ($document->getNodeQName($fnode) eq 'ltx:rule') {    # Or other stretchable element?
        Debug("   extend to " . ToString($reqw));
        $document->setAttribute($fnode, width => $reqw->toAttribute);
        $document->addClass($fnode, 'ltx_filled_leader');
        $unwrap = 1; }
      elsif (($fillw = $filler->getWidth) && ($fillw = $fillw->valueOf)) {
        my $n = int($reqw->valueOf / $fillw);
        Debug("  duplicate $n times");
        $document->addClass($container, 'ltx_filled_leader');
        for (my $i = 2 ; $i < $n ; $i++) {
          $document->absorb($filler); } } }
    else {
      $document->addClass($container, 'ltx_leader'); }
    $document->closeElement('ltx:text');
    $document->unwrapNodes($container) if $unwrap;    # avoid redundant <ltx:text><ltx:rule>
    return; },
  ## Hide the rule argument from contributing cell borders to any containing Alignment
  bounded => 1, beforeDigest => sub { $STATE->assignValue(Alignment => undef); }
);

Let('\cleaders', '\leaders');
Let('\xleaders', '\leaders');
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
1;

