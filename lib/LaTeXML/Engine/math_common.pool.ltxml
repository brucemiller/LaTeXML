# -*- mode: Perl -*-
# /=====================================================================\ #
# | math_common                                                         | #
# | Core TeX Implementation for LaTeXML                                 | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | Bruce Miller <bruce.miller@nist.gov>                        #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #
package LaTeXML::Package::Pool;
use strict;
use warnings;
use LaTeXML::Package;
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#----------------------------------------------------------------------
#  Actually from LaTeX; Table 3.3, Greek, p.41
#----------------------------------------------------------------------
DefMathI('\alpha',      undef, "\x{03B1}");
DefMathI('\beta',       undef, "\x{03B2}");
DefMathI('\gamma',      undef, "\x{03B3}");
DefMathI('\delta',      undef, "\x{03B4}");
DefMathI('\epsilon',    undef, "\x{03F5}");
DefMathI('\varepsilon', undef, "\x{03B5}");
DefMathI('\zeta',       undef, "\x{03B6}");
DefMathI('\eta',        undef, "\x{03B7}");
DefMathI('\theta',      undef, "\x{03B8}");
DefMathI('\vartheta',   undef, "\x{03D1}");
DefMathI('\iota',       undef, "\x{03B9}");
DefMathI('\kappa',      undef, "\x{03BA}");
DefMathI('\lambda',     undef, "\x{03BB}");
DefMathI('\mu',         undef, "\x{03BC}");
DefMathI('\nu',         undef, "\x{03BD}");
DefMathI('\xi',         undef, "\x{03BE}");
DefMathI('\pi',         undef, "\x{03C0}");
DefMathI('\varpi',      undef, "\x{03D6}");
DefMathI('\rho',        undef, "\x{03C1}");
DefMathI('\varrho',     undef, "\x{03F1}");
DefMathI('\sigma',      undef, "\x{03C3}");
DefMathI('\varsigma',   undef, "\x{03C2}");
DefMathI('\tau',        undef, "\x{03C4}");
DefMathI('\upsilon',    undef, "\x{03C5}");
DefMathI('\phi',        undef, "\x{03D5}");
DefMathI('\varphi',     undef, "\x{03C6}");
DefMathI('\chi',        undef, "\x{03C7}");
DefMathI('\psi',        undef, "\x{03C8}");
DefMathI('\omega',      undef, "\x{03C9}");
DefMathI('\Gamma',      undef, "\x{0393}");
DefMathI('\Delta',      undef, "\x{0394}");
DefMathI('\Theta',      undef, "\x{0398}");
DefMathI('\Lambda',     undef, "\x{039B}");
DefMathI('\Xi',         undef, "\x{039E}");
DefMathI('\Pi',         undef, "\x{03A0}");
DefMathI('\Sigma',      undef, "\x{03A3}");
DefMathI('\Upsilon',    undef, "\x{03A5}");
DefMathI('\Phi',        undef, "\x{03A6}");
DefMathI('\Psi',        undef, "\x{03A8}");
DefMathI('\Omega',      undef, "\x{03A9}");

DefMathI('\to', undef, "\x{2192}", role => 'ARROW'); # RIGHTWARDS ARROW??? a bit more explicitly relation-like?

#----------------------------------------------------------------------
# Actually from LaTeX; Table 3.7. Miscellaneous Symbols, p.43
#----------------------------------------------------------------------
# Some should be differential operators, qualifiers, ...
DefMathI('\aleph', undef, "\x{2135}");
DefMathI('\hbar',  undef, "\x{210F}", role => 'ID', meaning => 'Planck-constant-over-2-pi');
DefMathI('\imath', undef, "\x{0131}");
DefMathI('\jmath', undef, "\x{0237}");
DefMathI('\ell',   undef, "\x{2113}");
DefMathI('\wp',    undef, "\x{2118}", meaning => 'Weierstrass-p');
DefMathI('\Re',    undef, "\x{211C}", role    => 'OPFUNCTION', meaning => 'real-part');
DefMathI('\Im',    undef, "\x{2111}", role    => 'OPFUNCTION', meaning => 'imaginary-part');
DefMathI('\mho',   undef, "\x{2127}");

DefMathI('\prime',    undef, "\x{2032}", role => 'SUPOP', locked  => 1);
DefMathI('\emptyset', undef, "\x{2205}", role => 'ID',    meaning => 'empty-set');
DefMathI('\nabla',    undef, "\x{2207}", role => 'OPERATOR');
DefMathI('\surd',     undef, "\x{221A}", role => 'OPERATOR', meaning => 'square-root');
DefMathI('\top',      undef, "\x{22A4}", role => 'ADDOP',    meaning => 'top');
DefMathI('\bot',      undef, "\x{22A5}", role => 'ADDOP',    meaning => 'bottom');
DefMathI('\|',        undef, "\x{2225}", role => 'VERTBAR',  name    => '||');
# should get meaning => 'parallel-to' when used as infix, but NOT when for OPEN|CLOSE
DefMathI('\angle', undef, "\x{2220}");

# NOTE: This is probably the wrong role.
# Also, should probably carry info about Binding for OpenMath
DefMathI('\forall',    undef, "\x{2200}", role => 'BIGOP', meaning => 'for-all');
DefMathI('\exists',    undef, "\x{2203}", role => 'BIGOP', meaning => 'exists');
DefMathI('\neg',       undef, UTF(0xAC),  role => 'BIGOP', meaning => 'not');
DefMathI('\lnot',      undef, UTF(0xAC),  role => 'BIGOP', meaning => 'not');
DefMathI('\flat',      undef, "\x{266D}");
DefMathI('\natural',   undef, "\x{266E}");
DefMathI('\sharp',     undef, "\x{266F}");
DefMathI('\backslash', undef, UTF(0x5C),  role => 'MULOP');
DefMathI('\partial',   undef, "\x{2202}", role => 'DIFFOP', meaning => 'partial-differential');

DefMathI('\infty',       undef, "\x{221E}", role => 'ID', meaning => 'infinity');
DefMathI('\Box',         undef, "\x{25A1}");
DefMathI('\Diamond',     undef, "\x{25C7}");
DefMathI('\triangle',    undef, "\x{25B3}");
DefMathI('\clubsuit',    undef, "\x{2663}");
DefMathI('\diamondsuit', undef, "\x{2662}");
DefMathI('\heartsuit',   undef, "\x{2661}");
DefMathI('\spadesuit',   undef, "\x{2660}");

DefMacroI('\active@math@prime', undef, sub {
    my ($gullet) = @_;
    my @sup = (T_CS('\prime'));
    # Collect up all ', convering to \prime
    while ($gullet->ifNext(T_OTHER('\''))) {
      $gullet->readToken;
      push(@sup, T_CS('\prime')); }
    # Combine with any following superscript!
    # However, this is semantically screwed up!
    # We really need to set up separate superscripts, but at same level!
    if ($gullet->ifNext(T_SUPER)) {
      $gullet->readToken;
      push(@sup, $gullet->readArg->unlist); }
    (T_SUPER, T_BEGIN, @sup, T_END); },
  locked => 1);    # Only in math!
AssignMathcode("'" => 0x8000);
Let("'", '\active@math@prime');

#----------------------------------------------------------------------
DefMath('\smallint', "\x{222B}", meaning => 'integral', role => 'INTOP',
  font => { size => 9 }, scriptpos => \&doScriptpos, mathstyle => 'text');    # INTEGRAL

#----------------------------------------------------------------------
# Actually LaTeX; Table 3.8. Variable-sized Symbols, p.44.
#----------------------------------------------------------------------
DefMathI('\sum', undef, "\x{2211}",
  role      => 'SUMOP',
  scriptpos => \&doScriptpos,
  meaning   => 'sum',
  mathstyle => \&doVariablesizeOp);
DefMathI('\prod', undef, "\x{220F}",
  role      => 'SUMOP',
  scriptpos => \&doScriptpos,
  meaning   => 'product',
  mathstyle => \&doVariablesizeOp);
DefMathI('\coprod', undef, "\x{2210}",
  role      => 'SUMOP',
  scriptpos => \&doScriptpos,
  meaning   => 'coproduct',
  mathstyle => \&doVariablesizeOp);
DefMathI('\int', undef, "\x{222B}",
  role      => 'INTOP',
  meaning   => 'integral',
  mathstyle => \&doVariablesizeOp);
DefMathI('\oint', undef, "\x{222E}",
  role      => 'INTOP',
  meaning   => 'contour-integral',
  mathstyle => \&doVariablesizeOp);
DefMathI('\bigcap', undef, "\x{22C2}",    # versus \x{2229}
  role      => 'SUMOP',
  scriptpos => \&doScriptpos,
  meaning   => 'intersection',
  mathstyle => \&doVariablesizeOp);
DefMathI('\bigcup', undef, "\x{22C3}",    # versus \x{222A}
  role      => 'SUMOP',
  scriptpos => \&doScriptpos,
  meaning   => 'union',
  mathstyle => \&doVariablesizeOp);
DefMathI('\bigsqcup', undef, "\x{2A06}",    # versus \x{2294}
  role      => 'SUMOP',
  scriptpos => \&doScriptpos,
  meaning   => 'square-union',
  mathstyle => \&doVariablesizeOp);
DefMathI('\bigvee', undef, "\x{22C1}",      # versus \x{2229}
  role      => 'SUMOP',
  scriptpos => \&doScriptpos,
  meaning   => 'or',
  mathstyle => \&doVariablesizeOp);
DefMathI('\bigwedge', undef, "\x{22C0}",    # versus \x{2227}
  role      => 'SUMOP',
  scriptpos => \&doScriptpos,
  meaning   => 'and',
  mathstyle => \&doVariablesizeOp);
DefMathI('\bigodot', undef, "\x{2A00}",     # versus \x{2299}
  role      => 'SUMOP',                     #meaning=> ?
  scriptpos => \&doScriptpos,
  mathstyle => \&doVariablesizeOp);
DefMathI('\bigotimes', undef, "\x{2A02}",    # versus \x{2297}
  role      => 'SUMOP',
  scriptpos => \&doScriptpos,
  meaning   => 'tensor-product',
  mathstyle => \&doVariablesizeOp);
DefMathI('\bigoplus', undef, "\x{2A01}",     # versus \x{2295}
  role      => 'SUMOP',
  scriptpos => \&doScriptpos,
  meaning   => 'direct-sum',
  mathstyle => \&doVariablesizeOp);
DefMathI('\biguplus', undef, "\x{2A04}",     # versus \x{228e}
  role      => 'SUMOP',
  scriptpos => \&doScriptpos,
  meaning   => 'symmetric-difference',
  mathstyle => \&doVariablesizeOp);

#----------------------------------------------------------------------
# Actually from LaTeX; Table 3.4. Binary Operation Symbols, p.42
#----------------------------------------------------------------------
DefMathI('\pm',     undef, UTF(0xB1),  role => 'ADDOP', meaning => 'plus-or-minus');
DefMathI('\mp',     undef, "\x{2213}", role => 'ADDOP', meaning => 'minus-or-plus');
DefMathI('\times',  undef, UTF(0xD7),  role => 'MULOP', meaning => 'times');
DefMathI('\div',    undef, UTF(0xF7),  role => 'MULOP', meaning => 'divide');
DefMathI('\ast',    undef, "\x{2217}", role => 'MULOP');
DefMathI('\star',   undef, "\x{22C6}", role => 'MULOP');
DefMathI('\circ',   undef, "\x{2218}", role => 'MULOP', meaning => 'compose');
DefMathI('\bullet', undef, "\x{2219}", role => 'MULOP');
DefMathI('\cdot',   undef, "\x{22C5}", role => 'MULOP');
##  , meaning=>'inner-product');  that's pushing it a bit far...

# Need to classify set operations more carefully....
DefMathI('\cap',      undef, "\x{2229}", role => 'ADDOP', meaning => 'intersection');
DefMathI('\cup',      undef, "\x{222A}", role => 'ADDOP', meaning => 'union');
DefMathI('\uplus',    undef, "\x{228E}", role => 'ADDOP');
DefMathI('\sqcap',    undef, "\x{2293}", role => 'ADDOP', meaning => 'square-intersection');
DefMathI('\sqcup',    undef, "\x{2294}", role => 'ADDOP', meaning => 'square-union');
DefMathI('\vee',      undef, "\x{2228}", role => 'ADDOP', meaning => 'or');
DefMathI('\lor',      undef, "\x{2228}", role => 'ADDOP', meaning => 'or');
DefMathI('\wedge',    undef, "\x{2227}", role => 'ADDOP', meaning => 'and');
DefMathI('\land',     undef, "\x{2227}", role => 'ADDOP', meaning => 'and');
DefMathI('\setminus', undef, "\x{2216}", role => 'ADDOP', meaning => 'set-minus');
DefMathI('\wr',       undef, "\x{2240}", role => 'MULOP');

# Should this block be ADDOP or something else?
DefMathI('\diamond',         undef, "\x{22C4}", role => 'ADDOP');
DefMathI('\bigtriangleup',   undef, "\x{25B3}", role => 'ADDOP');
DefMathI('\bigtriangledown', undef, "\x{25BD}", role => 'ADDOP');
DefMathI('\triangleleft',    undef, "\x{22B2}", role => 'ADDOP');
DefMathI('\triangleright',   undef, "\x{22B3}", role => 'ADDOP');
DefMathI('\lhd',   undef, "\x{22B2}", role => 'ADDOP', meaning => 'subgroup-of');
DefMathI('\rhd',   undef, "\x{22B3}", role => 'ADDOP', meaning => 'contains-as-subgroup');
DefMathI('\unlhd', undef, "\x{22B4}", role => 'ADDOP', meaning => 'subgroup-of-or-equals');
DefMathI('\unrhd', undef, "\x{22B5}", role => 'ADDOP', meaning => 'contains-as-subgroup-or-equals');

DefMathI('\oplus',   undef, "\x{2295}", role => 'ADDOP', meaning => 'direct-sum');
DefMathI('\ominus',  undef, "\x{2296}", role => 'ADDOP', meaning => 'symmetric-difference');
DefMathI('\otimes',  undef, "\x{2297}", role => 'MULOP', meaning => 'tensor-product');
DefMathI('\oslash',  undef, "\x{2298}", role => 'MULOP');
DefMathI('\odot',    undef, "\x{2299}", role => 'MULOP', meaning => 'direct-product');
DefMathI('\bigcirc', undef, "\x{25CB}", role => 'MULOP');
DefMathI('\dagger',  undef, "\x{2020}", role => 'MULOP');
DefMathI('\ddagger', undef, "\x{2021}", role => 'MULOP');
DefMathI('\amalg',   undef, "\x{2210}", role => 'MULOP', meaning => 'coproduct');

#----------------------------------------------------------------------
# LaTeX; Table 3.5. Relation Symbols, p.43
#----------------------------------------------------------------------
DefMathI('\leq',        undef, "\x{2264}", role => 'RELOP', meaning => 'less-than-or-equals');
DefMathI('\prec',       undef, "\x{227A}", role => 'RELOP', meaning => 'precedes');
DefMathI('\preceq',     undef, "\x{2AAF}", role => 'RELOP', meaning => 'precedes-or-equals');
DefMathI('\ll',         undef, "\x{226A}", role => 'RELOP', meaning => 'much-less-than');
DefMathI('\subset',     undef, "\x{2282}", role => 'RELOP', meaning => 'subset-of');
DefMathI('\subseteq',   undef, "\x{2286}", role => 'RELOP', meaning => 'subset-of-or-equals');
DefMathI('\sqsubset',   undef, "\x{228F}", role => 'RELOP', meaning => 'square-image-of');
DefMathI('\sqsubseteq', undef, "\x{2291}", role => 'RELOP', meaning => 'square-image-of-or-equals');
DefMathI('\in',         undef, "\x{2208}", role => 'RELOP', meaning => 'element-of');
DefMathI('\vdash',      undef, "\x{22A2}", role => 'METARELOP', meaning => 'proves');

DefMathI('\geq',      undef, "\x{2265}", role => 'RELOP', meaning => 'greater-than-or-equals');
DefMathI('\succ',     undef, "\x{227B}", role => 'RELOP', meaning => 'succeeds');
DefMathI('\succeq',   undef, "\x{2AB0}", role => 'RELOP', meaning => 'succeeds-or-equals');
DefMathI('\gg',       undef, "\x{226B}", role => 'RELOP', meaning => 'much-greater-than');
DefMathI('\supset',   undef, "\x{2283}", role => 'RELOP', meaning => 'superset-of');
DefMathI('\supseteq', undef, "\x{2287}", role => 'RELOP', meaning => 'superset-of-or-equals');
DefMathI('\sqsupset', undef, "\x{2290}", role => 'RELOP', meaning => 'square-original-of');
DefMathI('\sqsupseteq', undef, "\x{2292}", role => 'RELOP', meaning => 'square-original-of-or-equals');
DefMathI('\ni',         undef, "\x{220B}", role => 'RELOP',     meaning => 'contains');
DefMathI('\dashv',      undef, "\x{22A3}", role => 'METARELOP', meaning => 'does-not-prove');

# I have the impression think that "identical" is a stronger notion than "equivalence"
# Note that the unicode here is called "Identical To",
# and that the notion of "equivalent to" usually involves the tilde operator.
DefMathI('\equiv',  undef, "\x{2261}", role => 'RELOP', meaning => 'equivalent-to');
DefMathI('\sim',    undef, "\x{223C}", role => 'RELOP', meaning => 'similar-to');
DefMathI('\simeq',  undef, "\x{2243}", role => 'RELOP', meaning => 'similar-to-or-equals');
DefMathI('\asymp',  undef, "\x{224D}", role => 'RELOP', meaning => 'asymptotically-equals');
DefMathI('\approx', undef, "\x{2248}", role => 'RELOP', meaning => 'approximately-equals');
DefMathI('\cong',   undef, "\x{2245}", role => 'RELOP', meaning => 'approximately-equals');
DefMathI('\neq',    undef, "\x{2260}", role => 'RELOP', meaning => 'not-equals');
DefMathI('\doteq',  undef, "\x{2250}", role => 'RELOP', meaning => 'approaches-limit');
DefMathI('\notin',  undef, "\x{2209}", role => 'RELOP', meaning => 'not-element-of');

DefMathI('\models', undef, "\x{22A7}", role => 'RELOP', meaning => 'models');
DefMathI('\perp',   undef, "\x{27C2}", role => 'RELOP', meaning => 'perpendicular-to');
DefMathI('\mid',    undef, "\x{2223}", role => 'VERTBAR');  # DIVIDES (RELOP?) ?? well, sometimes...
DefMathI('\parallel', undef, "\x{2225}", role => 'VERTBAR', meaning => 'parallel-to');
DefMathI('\bowtie',   undef, "\x{22C8}", role => 'RELOP');    # BOWTIE
DefMathI('\Join',     undef, "\x{2A1D}", role => 'RELOP', meaning => 'join');
DefMathI('\smile',    undef, "\x{2323}", role => 'RELOP');    # SMILE
DefMathI('\frown',    undef, "\x{2322}", role => 'RELOP');    # FROWN
DefMathI('\propto',   undef, "\x{221D}", role => 'RELOP', meaning => 'proportional-to');

# TeX defines these as alternate names...
Let('\le', '\leq');
Let('\ge', '\geq');
Let('\ne', '\neq');

# Discretionary times
DefMathI('\*', undef, "\x{2062}", role => 'MULOP', name => '', meaning => 'times');
#----------------------------------------------------------------------
# Not;  (Is fullwidth solidus appropriate for when \not appears in isolation?)
DefMathI('\not', undef, "\x{FF0F}", role => 'OPFUNCTION', meaning => 'not');
# Match negations of many operators
our %NOTS = ('=' => "\x{2260}", '<' => "\x{226E}", '>' => "\x{226F}",
  "\x{2208}" => "\x{2209}",                              #\in=>\notin
  "\x{2264}" => "\x{2270}", "\x{2265}" => "\x{2271}",    # Less eq, greater eq.
  "\x{227A}" => "\x{2280}", "\x{227B}" => "\x{2281}",    # prec, succ
  "\x{2AAF}" => "\x{22E0}", "\x{2AB0}" => "\x{22E1}",    # preceq, succeq
  "\x{2282}" => "\x{2284}", "\x{2283}" => "\x{2285}",    # subset, supset
  "\x{2286}" => "\x{2288}", "\x{2287}" => "\x{2289}",    # subseteq, supseteq
  "\x{2291}" => "\x{22E2}", "\x{2290}" => "\x{22E3}",    # sqsubseteq, sqsupseteq
  "\x{2261}" => "\x{2262}",                              # equiv
  "\x{224D}" => "\x{226D}", "\x{2248}" => "\x{2249}",    # asymp, approx
  "\x{22B2}" => "\x{22EA}", "\x{22B3}" => "\x{22EB}",    # lhd, rhd
  "\x{22B4}" => "\x{22EC}", "\x{22B5}" => "\x{22ED}",    # unlhd, unrhd
  "\x{2203}" => "\x{2204}",                              # Exists
);

# For a \not operator that is followed by anything, concoct an appropriate not or cancelation.
DefRewrite(select => ["descendant-or-self::ltx:XMTok[text()='\x{FF0F}' and \@meaning='not']"
      . "[ following-sibling::*]", 2],
  replace => sub {
    my ($doc, $not, $thing) = @_;
    my $text = ($doc->getModel->getNodeQName($thing) eq 'ltx:XMTok')
      && $thing->textContent;

    if ((!defined $text) || (length($text) != 1)) {    # Not simple char token.
      my $box = $doc->getNodeBox($not);
      $doc->openElement('ltx:XMApp', _box => $box);    # Wrap with a cancel op
      my $strike = $doc->insertMathToken(undef, role => 'ENCLOSE', enclose => 'updiagonalstrike',
        meaning => 'not', _box => $box);
      if (my $id = $not->getAttribute('xml:id')) {
        $not->removeAttribute('xml:id');
        $doc->unRecordID($id);
        $doc->setAttribute($strike, 'xml:id' => $id); }
      $doc->getNode->appendChild($thing);
      $doc->closeElement('ltx:XMApp'); }
    else {
      # For simple tokens, we'll modify the relevant content & attributes
      # [children removed, id's presumably ignorable]
      map { $_->unbindNode() } $thing->childNodes;
      my $new = defined $NOTS{$text} ? $NOTS{$text} : $text . "\x{0338}";
      $thing->appendText($new);
      if (my $meaning = $thing->getAttribute('meaning')) {
        $doc->setAttribute($thing, meaning => "not-$meaning"); }
      if (my $name = $thing->getAttribute('name') || $text) {
        $doc->setAttribute($thing, name => "not-$name"); }
      # and put the node back in
      $doc->getNode->appendChild($thing);
      # Since the <not> element is disappearing, if it had an id that was referenced...!?!?
      if (my $id = $not->getAttribute('xml:id')) {
        foreach my $n ($doc->findnodes("descendant-or-self::ltx:XMRef[\@idref='$id']")) {
          $doc->removeNode($n); } }    # ? Hopefully this is safe.
} });

#----------------------------------------------------------------------
# \joinrel
DefMathI('\relbar', undef, "-", role => 'RELOP');    # ???
DefMathI('\Relbar', undef, "=", role => 'RELOP');    # ???

# \joinrel is \mathrel{\mkern-3\mu}
# Ah, but the Effect is to join 2 "relations" into one!
DefPrimitiveI('\joinrel', undef, sub {
    my ($stomach, $op) = @_;
    my $gullet = $stomach->getGullet;
    $gullet->skipSpaces;
    my $left = $LaTeXML::LIST[-1];
    if (!$left) {    # Nothing there?...
      return (); }    # I guess this becomes a no-op???
    else {
      pop(@LaTeXML::LIST);
      my @stuff = ();
      while (my $tok = $gullet->readXToken(0)) {
        @stuff = $stomach->invokeToken($tok);
        last if @stuff; }
      return () unless @stuff;    # no-op ????
      my $right = shift(@stuff);
      (@stuff,
        LaTeXML::Core::Whatsit->new(LookupDefinition(T_CS('\@@joinrel')), [$left, $right],
          locator => $gullet->getLocator,
          font    => $right->getFont, isMath => 1)); } });

DefConstructor('\@@joinrel{}{}', sub {
    my ($document, $left, $right) = @_;
    $document->absorb($left);
    $document->absorb($right);
    # Now if last 2 items are XMTok, replace by a single token with joined content (& attr?)
    my $node  = $document->getNode;
    my @nodes = $document->getChildElements($node);
    if (scalar(@nodes) >= 2) {
      my @rels = ($nodes[-2], $nodes[-1]);
      if (grep { $document->getNodeQName($_) eq 'ltx:XMTok' } @rels) {
        my %roles = ();
        map { $roles{ $_->getAttribute('role') } = 1 } @rels;
        my $role = (scalar(keys %roles) == 1 ? [keys %roles]->[0] : ($roles{ARROW} ? 'ARROW' : 'RELOP'));
        map { $node->removeChild($_) } @rels;
        $document->insertElement('ltx:XMTok', [map { $_->textContent } @rels], role => $role);
  } } },
  reversion => '#1\joinrel #2');

#----------------------------------------------------------------------
# LaTeX; Table 3.6. Arrow Symbols, p.43
#----------------------------------------------------------------------
# Arrows get treated somewhat like relations (or meta-relations),
# but it's hard to associate any particular "meaning" to them.

DefMathI('\leftarrow',      undef, "\x{2190}", role => 'ARROW');         # LEFTWARDS ARROW
DefMathI('\Leftarrow',      undef, "\x{21D0}", role => 'ARROW');         # LEFTWARDS DOUBLE ARROW
DefMathI('\rightarrow',     undef, "\x{2192}", role => 'ARROW');         # RIGHTWARDS ARROW
DefMathI('\Rightarrow',     undef, "\x{21D2}", role => 'ARROW');         # RIGHTWARDS DOUBLE ARROW
DefMathI('\leftrightarrow', undef, "\x{2194}", role => 'METARELOP');     # LEFT RIGHT ARROW
DefMathI('\Leftrightarrow', undef, "\x{21D4}", role => 'METARELOP');     # LEFT RIGHT DOUBLE ARROW
DefMathI('\iff', undef, "\x{21D4}", role => 'METARELOP', meaning => 'iff'); # LEFT RIGHT DOUBLE ARROW
DefMathI('\mapsto',        undef, "\x{21A6}", role => 'ARROW', meaning => 'maps-to');
DefMathI('\hookleftarrow', undef, "\x{21A9}", role => 'ARROW');    # LEFTWARDS ARROW WITH HOOK
DefMathI('\leftharpoonup', undef, "\x{21BC}", role => 'ARROW'); # LEFTWARDS HARPOON WITH BARB UPWARDS
DefMathI('\leftharpoondown', undef, "\x{21BD}", role => 'ARROW'); # LEFTWARDS HARPOON WITH BARB DOWNWARDS
DefMathI('\rightleftharpoons', undef, "\x{21CC}", role => 'METARELOP'); # RIGHTWARDS HARPOON OVER LEFTWARDS HARPOON
DefMathI('\longleftarrow',      undef, "\x{27F5}", role => 'ARROW');  # LONG LEFTWARDS ARROW
DefMathI('\Longleftarrow',      undef, "\x{27F8}", role => 'ARROW');  # LONG LEFTWARDS DOUBLE ARROW
DefMathI('\longrightarrow',     undef, "\x{27F6}", role => 'ARROW');  # LONG RIGHTWARDS ARROW
DefMathI('\Longrightarrow',     undef, "\x{27F9}", role => 'ARROW');  # LONG RIGHTWARDS DOUBLE ARROW
DefMathI('\longleftrightarrow', undef, "\x{27F7}", role => 'METARELOP');    # LONG LEFT RIGHT ARROW
DefMathI('\Longleftrightarrow', undef, "\x{27FA}", role => 'METARELOP'); # LONG LEFT RIGHT DOUBLE ARROW
DefMathI('\longmapsto',     undef, "\x{27FC}", role => 'ARROW');    # LONG RIGHTWARDS ARROW FROM BAR
DefMathI('\hookrightarrow', undef, "\x{21AA}", role => 'ARROW');    # RIGHTWARDS ARROW WITH HOOK
DefMathI('\rightharpoonup', undef, "\x{21C0}", role => 'ARROW'); # RIGHTWARDS HARPOON WITH BARB UPWARDS
DefMathI('\rightharpoondown', undef, "\x{21C1}", role => 'ARROW'); # RIGHTWARDS HARPOON WITH BARB DOWNWARDS
DefMathI('\leadsto',          undef, "\x{219D}", role => 'ARROW', meaning => 'leads-to');

DefMathI('\uparrow',     undef, "\x{2191}", role => 'ARROW');      # UPWARDS ARROW
DefMathI('\Uparrow',     undef, "\x{21D1}", role => 'ARROW');      # UPWARDS DOUBLE ARROW
DefMathI('\downarrow',   undef, "\x{2193}", role => 'ARROW');      # DOWNWARDS ARROW
DefMathI('\Downarrow',   undef, "\x{21D3}", role => 'ARROW');      # DOWNWARDS DOUBLE ARROW
DefMathI('\updownarrow', undef, "\x{2195}", role => 'ARROW');      # UP DOWN ARROW
DefMathI('\Updownarrow', undef, "\x{21D5}", role => 'ARROW');      # UP DOWN DOUBLE ARROW
DefMathI('\nearrow',     undef, "\x{2197}", role => 'ARROW');      # NORTH EAST ARROW
DefMathI('\searrow',     undef, "\x{2198}", role => 'ARROW');      # SOUTH EAST ARROW
DefMathI('\swarrow',     undef, "\x{2199}", role => 'ARROW');      # SOUTH WEST ARROW
DefMathI('\nwarrow',     undef, "\x{2196}", role => 'ARROW');      # NORTH WEST ARROW

# \mapstochar (3237), \lhook(312C), \rhook(312D)
# These are really wrong; I can't find the right Unicode Glyphs.
# These are only fragments intended to be assembled into meaningful(?) symbols.
DefMathI('\mapstochar', undef, "\x{2E20}");    # TeX 3237
DefMathI('\lhook',      undef, "\x{2E26}");    # TeX 312C
DefMathI('\rhook',      undef, "\x{2E27}");    # TeX 312D

#======================================================================
# TeX Book, Appendix B. p. 359

# Ah, since \ldots can appear in text and math....
DefMacroI('\ldots', undef, '\lx@ldots');
DefConstructorI('\lx@ldots', undef,
  "?#isMath(<ltx:XMTok name='ldots' font='#font' role='ID'>\x{2026}</ltx:XMTok>)(\x{2026})",
  sizer      => "\x{2026}",
  reversion  => '\ldots',
  properties => sub {
    (LookupValue('IN_MATH')
      ? (font => LookupValue('font')->merge(family => 'serif',
          series => 'medium', shape => 'upright')->specialize("\x{2026}"))
      : ()); });    # Since not DefMath!
                    # And so can \vdots
DefConstructorI('\vdots', undef,
  "?#isMath(<ltx:XMTok name='vdots' font='#font' role='ID'>\x{22EE}</ltx:XMTok>)(\x{22EE})",
  sizer      => "\x{22EE}",
  enterHorizontal => 1,
  properties => sub {
    (LookupValue('IN_MATH')
      ? (font => LookupValue('font')->merge(family => 'serif',
          series => 'medium', shape => 'upright')->specialize("\x{22EE}"))
      : ()); });    # Since not DefMath!
                    # But not these!
DefMathI('\cdots', undef, "\x{22EF}", role => 'ID');    # MIDLINE HORIZONTAL ELLIPSIS

DefMathI('\ddots', undef, "\x{22F1}", role => 'ID');           # DOWN RIGHT DIAGONAL ELLIPSIS
DefMathI('\colon', undef, ':',        role => 'METARELOP');    # Seems like good default role
    # Note that amsmath redefines \dots to be `smart'.
    # Aha, also can be in text...
DefConstructorI('\dots', undef,
  "?#isMath(<ltx:XMTok name='dots' font='#font' role='ID'>\x{2026}</ltx:XMTok>)(\x{2026})",
  sizer      => "\x{2026}",
  enterHorizontal => 1,
  properties => sub {
    (LookupValue('IN_MATH')
      ? (font => LookupValue('font')->merge(family => 'serif',
          series => 'medium', shape => 'upright')->specialize("\x{2026}"))
      : ()); });    # Since not DefMath!

# And while we're at it...

# Pretest for XMath to keep from interpreting math that the DOM may not allow!!
##DefMathRewrite(xpath=>'descendant-or-self::ltx:XMath',match=>'\cdot\cdot\cdot',replace=>'\cdots');

DefMathLigature("\x{22C5}\x{22C5}\x{22C5}" => "\x{22EF}", role => 'ID', name => 'cdots');

DefLigature(qr{\.\.\.}, "\x{2026}", fontTest => sub { $_[0]->getFamily ne 'typewriter'; });  # ldots

#DefMathRewrite(xpath=>'descendant-or-self::ltx:XMath',match=>'...',replace=>'\ldots');
DefMathLigature("..." => "\x{2026}", role => 'ID', name => 'ldots');

#----------------------------------------------------------------------
# Math Accents.
#----------------------------------------------------------------------
# LaTeX; Table 3.11. Math Mode Accents, p.50.
# Are these all TeX (or LaTeX)?
# Note that most of these should NOT be stretchy, by default!
DefMath('\hat Digested', UTF(0x5E),
  operator_role => 'OVERACCENT', operator_stretchy => 'false');
DefMath('\check Digested', "\x{02C7}",
  operator_role => 'OVERACCENT', operator_stretchy => 'false');    # CARON
DefMath('\breve Digested', "\x{02D8}", operator_role => 'OVERACCENT');    # BREVE
DefMath('\acute Digested', UTF(0xB4),  operator_role => 'OVERACCENT');    # ACUTE ACCENT
DefMath('\grave Digested', UTF(0x60),  operator_role => 'OVERACCENT');    # GRAVE ACCENT
DefMath('\tilde Digested', UTF(0x7E),
  operator_role => 'OVERACCENT', operator_stretchy => 'false');           # TILDE
DefMath('\bar Digested', UTF(0xAF),
  operator_role => 'OVERACCENT', operator_stretchy => 'false');           # MACRON
DefMath('\vec Digested', "\x{2192}",
  operator_role => 'OVERACCENT', operator_stretchy => 'false');           # RIGHTWARDS ARROW
DefMath('\dot Digested',  "\x{02D9}", operator_role => 'OVERACCENT');     # DOT ABOVE
DefMath('\ddot Digested', UTF(0xA8),  operator_role => 'OVERACCENT');     # DIAERESIS
DefMath('\widehat Digested', UTF(0x5E), operator_role => 'OVERACCENT'); # CIRCUMFLEX ACCENT [plain? also amsfonts]
DefMath('\widetilde Digested', UTF(0x7E), operator_role => 'OVERACCENT'); # TILDE [plain? also amsfonts]
# # These aren't handled as simple accents by TeX, so no Digested
# DefMath('\overbrace {}', "\x{23DE}", operator_role => 'OVERACCENT',       # TOP CURLY BRACKET
#   scriptpos => 'mid', operator_stretchy => 'true', robust => 1);
# DefMath('\underbrace {}', "\x{23DF}", operator_role => 'UNDERACCENT',     # BOTTOM CURLY BRACKET
#   scriptpos => 'mid', operator_stretchy => 'true', robust => 1);
Let('\overbrace',  '\lx@math@overbrace');
Let('\underbrace', '\lx@math@underbrace');

# NOTE that all the above accents REQUIRE math mode
# EXCEPT underline, overrightarrow and overleftarrow!

Let('\underbar', '\underline');    # Will anyone notice?

DefMacro('\overrightarrow{}', '\protect\ifmmode\lx@math@overrightarrow{#1}\else$\lx@math@overrightarrow{#1}$\fi');
DefMacro('\overleftarrow{}', '\protect\ifmmode\lx@math@overleftarrow{#1}\else$\lx@math@overleftarrow{#1}$\fi');

DefMacro('\skew{}{}{}', '{#2{#3\mkern#1mu}\mkern-#1mu}{}');    # ignore the subtle spacing for now?
#----------------------------------------------------------------------
# LaTeX; Table 3.10. Delimiters, p.47
#----------------------------------------------------------------------
# The meaning of OPEN/CLOSE tends to depend upon the pairing,
# rather than the individual tokens.
# This meaning is handled in MathParser (for now)

DefMacroI('\{', undef, '\ifmmode\lx@math@lbrace\else\lx@text@lbrace\fi', protected => 1);
DefMacroI('\}', undef, '\ifmmode\lx@math@rbrace\else\lx@text@rbrace\fi', protected => 1);
DefMathI('\lx@math@lbrace', undef, '{', role => 'OPEN',  stretchy => 'false', alias => '\{');
DefMathI('\lx@math@rbrace', undef, '}', role => 'CLOSE', stretchy => 'false', alias => '\}');
DefPrimitiveI('\lx@text@lbrace', undef, '{', alias => '\{',
  #  font => { specialize => "{" });
  font => { shape => 'upright' }, bounded => 1);    # Since not DefMath!
DefPrimitiveI('\lx@text@rbrace', undef, '}', alias => '\}',
  #  font => { specialize => "}" });    # Since not DefMath!
  font => { shape => 'upright' }, bounded => 1);    # Since not DefMath!
Let('\lbrace', '\{');
Let('\lbrack', T_OTHER('['));
Let('\rbrace', '\}');
Let('\rbrack', T_OTHER(']'));
DefMathI('\lceil',  undef, "\x{2308}", role => 'OPEN',  stretchy => 'false');    # LEFT CEILING
DefMathI('\rceil',  undef, "\x{2309}", role => 'CLOSE', stretchy => 'false');    # RIGHT CEILING
DefMathI('\lfloor', undef, "\x{230A}", role => 'OPEN',  stretchy => 'false');    # LEFT FLOOR
DefMathI('\rfloor', undef, "\x{230B}", role => 'CLOSE', stretchy => 'false');    # RIGHT FLOOR
    # Note: We should be using 27E8,27E9, which are "mathematical", not 2329,232A
DefMathI('\langle', undef, "\x{27E8}", role => 'OPEN', stretchy => 'false'); # LEFT-POINTING ANGLE BRACKET
DefMathI('\rangle', undef, "\x{27E9}", role => 'CLOSE', stretchy => 'false'); # RIGHT-POINTING ANGLE BRACKET

# Not sure these should be defined here, or latex, or even latex compat mode.
DefMathI('\lgroup', undef, "(", font => { series => 'bold' }, role => 'OPEN',  stretchy => 'false');
DefMathI('\rgroup', undef, ")", font => { series => 'bold' }, role => 'CLOSE', stretchy => 'false');
DefMathI('\bracevert', undef, "|", font => { series => 'bold' }, role => 'VERTBAR');

## DefMath('\lmoustache',"???", font=>{series=>'bold'}, role=>'OPEN');
## DefMath('\rmoustache',"???", font=>{series=>'bold'}, role=>'OPEN');

# TeX marks some symbols as delimiters which can be used with \left,\right,
# but many of which have different grammatical roles otherwise, eg. arrows, <, >.
# Short of setting up TeX's complicated encoding machinery, I need an explicit
# mapping.  Unfortunately, this doesn't (yet) support people declaring thier own delimiters!

# These expand into \left#1, so the bracing disappears; only enlarge the 1st part of #1!
DefConstructor('\big TeXDelimiter',  '#1', bounded => 1, font => { size => 'big' },
  afterConstruct => sub { augmentDelimiterProperties($_[0], $_[1], undef, 0); });
DefConstructor('\Big TeXDelimiter',  '#1', bounded => 1, font => { size => 'Big' },
  afterConstruct => sub { augmentDelimiterProperties($_[0], $_[1], undef, 0); });
DefConstructor('\bigg TeXDelimiter', '#1', bounded => 1, font => { size => 'bigg' },
  afterConstruct => sub { augmentDelimiterProperties($_[0], $_[1], undef, 0); });
DefConstructor('\Bigg TeXDelimiter', '#1', bounded => 1, font => { size => 'Bigg' },
  afterConstruct => sub { augmentDelimiterProperties($_[0], $_[1], undef, 0); });

# The "m" versions are defined in e-Tex and other places.
DefConstructor('\bigl TeXDelimiter', '#1', bounded => 1, font => { size => 'big' },
  afterConstruct => sub { augmentDelimiterProperties($_[0], $_[1], 'OPEN', 0); });
DefConstructor('\bigm TeXDelimiter', '#1', bounded => 1, font => { size => 'big' },
  afterConstruct => sub { augmentDelimiterProperties($_[0], $_[1], 'MIDDLE', 0); });
DefConstructor('\bigr TeXDelimiter', '#1', bounded => 1, font => { size => 'big' },
  afterConstruct => sub { augmentDelimiterProperties($_[0], $_[1], 'CLOSE', 0); });

DefConstructor('\Bigl TeXDelimiter', '#1', bounded => 1, font => { size => 'Big' },
  afterConstruct => sub { augmentDelimiterProperties($_[0], $_[1], 'OPEN', 0); });
DefConstructor('\Bigm TeXDelimiter', '#1', bounded => 1, font => { size => 'Big' },
  afterConstruct => sub { augmentDelimiterProperties($_[0], $_[1], 'MIDDLE', 0); });
DefConstructor('\Bigr TeXDelimiter', '#1', bounded => 1, font => { size => 'Big' },
  afterConstruct => sub { augmentDelimiterProperties($_[0], $_[1], 'CLOSE', 0); });

DefConstructor('\biggl TeXDelimiter', '#1', bounded => 1, font => { size => 'bigg' },
  afterConstruct => sub { augmentDelimiterProperties($_[0], $_[1], 'OPEN', 0); });
DefConstructor('\biggm TeXDelimiter', '#1', bounded => 1, font => { size => 'bigg' },
  afterConstruct => sub { augmentDelimiterProperties($_[0], $_[1], 'MIDDLE', 0); });
DefConstructor('\biggr TeXDelimiter', '#1', bounded => 1, font => { size => 'bigg' },
  afterConstruct => sub { augmentDelimiterProperties($_[0], $_[1], 'CLOSE', 0); });

DefConstructor('\Biggl TeXDelimiter', '#1', bounded => 1, font => { size => 'Bigg' },
  afterConstruct => sub { augmentDelimiterProperties($_[0], $_[1], 'OPEN', 0); });
DefConstructor('\Biggm TeXDelimiter', '#1', bounded => 1, font => { size => 'Bigg' },
  afterConstruct => sub { augmentDelimiterProperties($_[0], $_[1], 'MIDDLE', 0); });
DefConstructor('\Biggr TeXDelimiter', '#1', bounded => 1, font => { size => 'Bigg' },
  afterConstruct => sub { augmentDelimiterProperties($_[0], $_[1], 'CLOSE', 0); });

Let('\vert', T_OTHER('|'));
Let('\Vert', '\|');

#======================================================================
# TeX Book, Appendix B. p. 360

DefMacro('\choose',
  '\lx@generalized@over{\choose}{meaning=binomial,thickness=0pt,left=\lx@left(,right=\lx@right)}');
DefMacro('\brace',
  '\lx@generalized@over{\brace}{thickness=0pt,left=\lx@left\{,right=\lx@right\}}');
DefMacro('\brack',
  '\lx@generalized@over{\brack}{thickness=0pt,left=\lx@left[,right=\lx@right]}');

DefMacro('\mathpalette{}{}',
  '\mathchoice{#1\displaystyle{#2}}{#1\textstyle{#2}}'
    . '{#1\scriptstyle{#2}}{#1\scriptscriptstyle{#2}}');

DefConstructor('\phantom{}',
  "?#isMath(<ltx:XMHint width='#width' height='#height' depth='#depth' name='phantom'/>)"
    . "(<ltx:text class='ltx_phantom'>#1</ltx:text>)",    # !?!?!?!
  properties  => { isSpace => 1 },
  afterDigest => sub {
    my $whatsit = $_[1];
    my ($w, $h, $d) = $whatsit->getArg(1)->getSize;
    $whatsit->setProperties(width => $w, height => $h, depth => $d);
    return; });

DefConstructor('\hphantom{}',
  "?#isMath(<ltx:XMHint width='#width' name='hphantom'/>)"
    . "(<ltx:text class='ltx_phantom'>#1</ltx:text>)",    # !?!?!?!
  properties  => { isSpace => 1 },
  afterDigest => sub {
    my $whatsit = $_[1];
    my ($w, $h, $d) = $whatsit->getArg(1)->getSize;
    $whatsit->setProperties(width => $w, height => $h, depth => $d);
    return; });

DefConstructor('\vphantom{}',
  "?#isMath(<ltx:XMHint height='#height' depth='#depth' name='vphantom'/>)"
    . "(<ltx:text class='ltx_phantom'>#1</ltx:text>)",    # !?!?!?!
  properties  => { isSpace => 1 },
  afterDigest => sub {
    my $whatsit = $_[1];
    my ($w, $h, $d) = $whatsit->getArg(1)->getSize;
    $whatsit->setProperties(width => $w, height => $h, depth => $d);
    return; });

DefConstructor('\mathstrut', "?#isMath(<ltx:XMHint name='mathstrut'/>)()",
  properties => { isSpace => 1 });
DefConstructor('\smash{}', "#1");    # well, what?

#======================================================================
# TeX Book, Appendix B. p. 361

# This is actually LaTeX's definition, but let's just do it this way.
DefConstructor('\sqrt OptionalInScriptStyle Digested',
  "?#1(<ltx:XMApp><ltx:XMTok meaning='nth-root'/>"
    . "<ltx:XMArg>#1</ltx:XMArg><ltx:XMArg>#2</ltx:XMArg>"
    . "</ltx:XMApp>)"
    . "(<ltx:XMApp><ltx:XMTok meaning='square-root'/>"
    . "<ltx:XMArg>#2</ltx:XMArg></ltx:XMApp>)");

DefParameterType('ScriptStyleUntil', sub {
    my ($gullet, $until) = @_;
    $gullet->readUntil($until); },
  beforeDigest => sub {
    $_[0]->bgroup;
    MergeFont(mathstyle => 'script'); },
  afterDigest => sub {
    $_[0]->egroup; },
  reversion => sub { (T_BEGIN, Revert($_[0]), T_END); });

DefConstructor('\root ScriptStyleUntil:\of {}',
  "<ltx:XMApp><ltx:XMTok meaning='nth-root'/>"
    . "<ltx:XMArg>#1</ltx:XMArg><ltx:XMArg>#2</ltx:XMArg>"
    . "</ltx:XMApp>",
  reversion => '\root #1 \of {#2}');

#----------------------------------------------------------------------
# LaTeX; Table 3.9. Log-like Functions, p.44.
#----------------------------------------------------------------------
# NOTE: Classifying some as TRIGFUNCTION might clarify 'pi' ambiguities ?
DefMathI('\arccos', undef, "arccos", role => 'OPFUNCTION', meaning => 'inverse-cosine');
DefMathI('\arcsin', undef, "arcsin", role => 'OPFUNCTION', meaning => 'inverse-sine');
DefMathI('\arctan', undef, "arctan", role => 'OPFUNCTION', meaning => 'inverse-tangent');
DefMathI('\arg',    undef, "arg",    role => 'OPFUNCTION', meaning => 'argument');

DefMathI('\cos',  undef, "cos",  role => 'TRIGFUNCTION', meaning => 'cosine');
DefMathI('\cosh', undef, "cosh", role => 'TRIGFUNCTION', meaning => 'hyperbolic-cosine');
DefMathI('\cot',  undef, "cot",  role => 'TRIGFUNCTION', meaning => 'cotangent');
DefMathI('\coth', undef, "coth", role => 'TRIGFUNCTION', meaning => 'hyperbolic-cotangent');

DefMathI('\csc', undef, "csc", role => 'TRIGFUNCTION', meaning => 'cosecant');
DefMathI('\deg', undef, "deg", role => 'OPFUNCTION',   meaning => 'degree');
DefMathI('\det', undef, "det", role => 'LIMITOP', meaning => 'determinant',
  scriptpos => \&doScriptpos);
DefMathI('\dim', undef, "dim", role => 'LIMITOP', meaning => 'dimension');

DefMathI('\exp', undef, "exp", role => 'OPFUNCTION', meaning => 'exponential');
DefMathI('\gcd', undef, "gcd", role => 'OPFUNCTION', meaning => 'gcd',
  scriptpos => \&doScriptpos);
DefMathI('\hom', undef, "hom", role => 'OPFUNCTION');
DefMathI('\inf', undef, "inf", role => 'LIMITOP', meaning => 'infimum',
  scriptpos => \&doScriptpos);

DefMathI('\ker', undef, "ker", role => 'OPFUNCTION', meaning => 'kernel');
DefMathI('\lg', undef, "lg", role => 'OPFUNCTION');
DefMathI('\lim', undef, "lim", role => 'LIMITOP', meaning => 'limit',
  scriptpos => \&doScriptpos);
DefMathI('\liminf', undef, "lim inf", role => 'LIMITOP', meaning => 'limit-infimum',
  scriptpos => \&doScriptpos);

DefMathI('\limsup', undef, "lim sup", role => 'LIMITOP', meaning => 'limit-supremum',
  scriptpos => \&doScriptpos);
DefMathI('\ln',  undef, "ln",  role => 'OPFUNCTION', meaning => 'natural-logarithm');
DefMathI('\log', undef, "log", role => 'OPFUNCTION', meaning => 'logarithm');
DefMathI('\max', undef, "max", role => 'OPFUNCTION', meaning => 'maximum',
  scriptpos => \&doScriptpos);

DefMathI('\min', undef, "min", role => 'OPFUNCTION', meaning => 'minimum',
  scriptpos => \&doScriptpos);
DefMathI('\Pr',  undef, "Pr",  role => 'OPFUNCTION',   scriptpos => \&doScriptpos);
DefMathI('\sec', undef, "sec", role => 'TRIGFUNCTION', meaning   => 'secant');
DefMathI('\sin', undef, "sin", role => 'TRIGFUNCTION', meaning   => 'sine');

DefMathI('\sinh', undef, "sinh", role => 'TRIGFUNCTION', meaning => 'hyperbolic-sine');
DefMathI('\sup', undef, "sup", role => 'LIMITOP', meaning => 'supremum',
  scriptpos => \&doScriptpos);
DefMathI('\tan',  undef, "tan",  role => 'TRIGFUNCTION', meaning => 'tangent');
DefMathI('\tanh', undef, "tanh", role => 'TRIGFUNCTION', meaning => 'hyperbolic-tangent');

#----------------------------------------------------------------------
# Modulo

DefMath('\pmod{}', '\;\;(\mathop{{\rm mod}} #1)', role => 'MODIFIER');    #  , meaning=>'modulo');
DefMath('\bmod', 'mod', role => 'MODIFIEROP', meaning => 'modulo');

#======================================================================
# After all other rewrites have acted, a little cleanup
# [This suggests that it should be (one of) the LAST (math) rewrite applied?
# Do we need to define it last?]
DefRewrite(xpath => 'descendant-or-self::ltx:XMWrap[count(child::*)=1]',
  replace => sub { my ($document, $wrap) = @_;
    if (my $node = $document->getFirstChildElement($wrap)) {
      # Copy attributes but NOT internal ones,
      # NOR xml:id, else we get clashes
      foreach my $attribute ($wrap->attributes) {
        if ($attribute->nodeType == XML_ATTRIBUTE_NODE) {
          my $attr = $document->getNodeQName($attribute);
          $document->setAttribute($node, $attr => $attribute->getValue)
            unless ($attr eq 'xml:id') || $attr =~ /^_/;
          if    ($attr =~ /^_/) { }
          elsif ($attr eq 'xml:id') {
            my $id = $attribute->getValue;
            if (my $previd = $node->getAttribute('xml:id')) {    # Keep original id
                  # but swap any references to the one on the wrapper!
              foreach my $ref ($document->findnodes("//*[\@idref='$id']")) {
                $ref->setAttribute(idref => $previd); }
              $wrap->removeAttribute('xml"id');
              $document->unRecordID($id); }
            else {
              $wrap->removeAttribute('xml:id');
              $document->unRecordID($id);
              $document->setAttribute($node, 'xml:id' => $id); } }
          else {
            $document->setAttribute($node, $attr => $attribute->getValue); } } }
      # But keep $node's font from being overwritten.
      $document->setNodeFont($wrap, $document->getNodeFont($node));
      ## WHY THIS????
      $document->getNode->appendChild($node);
} });

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Stop at
# TeX Book, Appendix B. p. 362
1;
